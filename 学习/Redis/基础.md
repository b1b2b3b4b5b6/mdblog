# 基础
## Redis定义
是C语言开发的一个开源高性能键值对的内存非关系型数据库，可用作数据库，缓存，消息中间件。
## 特点
* 10W QPS
* 单进程单线程，线程安全，采用IO多路复用机制
* 丰富的数据类型
* 支持数据持久化
* 高可用：主从复制，哨兵
* 可用作分布式锁
* 可用作消息中间件，支持发布订阅

## 数据类型
| 类型    | 简介                                             | 特性                                          | 场景                 |
| :----- | :---------------------------------------------- | :-------------------------------------------- | :------------------ |
| string | 二进制安全                                       | 可以包含任何数据,最大512M                       |                     |
| hash   | 键值对集合                                       | 适合存储对象,渐进式rehash                       | 属性                 |
| list   | 链表                                             | 增删快，提供了操作某一元素的api,索引定位O(n)      | 消息队列             |
| set    | hash表实现，元素不重复                            | 增删查的复杂度为O(1),提供了求交集,并集,差集的操作 | 共同好友             |
| zset   | 将set中的元素增加权重参数score，元素按score有序排列 | 数据插入集合时,已经进行了天然排序,跳跃链表        | 排行榜,带权重消息队列 |
> 渐进式Rehash同时保留旧数组和新数组, 然后在定时任务中及后续对hash的指令操作中逐渐将旧数组挂接的元素迁移到新数组上

## 容器型数据结构的通用规则
* cerate if not exists
* drop if no elements

## 分布式锁
* `可重入性`由应用层实现

### 初始
* setnx    占坑
* del 删除
> del未执行造成死锁

### 增加expire
* setnx    占坑
* expire   设置超时, 自动删除
* del 删除
> setnx和expire无法构成原子, setnx执行而expire未执行

### 使用set拓展参数
* set lock:codehole true ex 5 nx 占坑同时设置超时
* del
> 线程1持锁期间若执行时间大于超时时间, 线程二获取到锁, 线程1释放锁(非法), 线程3获取锁(非法)

### 为set指令的value设置随机数, 防止非法释放
* set(key, tag, nx=true, ex=5)
* if tag equal
* del
> if和del无法构成原子

### 使用lua脚本(保证多个指令的原子性执行)

## 工具


### 位图
* 位图是普通的字符串,可一个使用get/set直接获取和设置整个位图的内容
* 可以使用位图操作getbit/setbit将byte数组看成`位数组`来处理
* bitcount统计
* bitpos查找
* gitfield get/set/increby 指定位片段进行读写

### HyperLogLog
* 统计UV数据, 近似精确
* pfadd 增加
* pfcount 统计

### 布隆过滤器
* 判断元素是否在集合中, 近似
* bf.add 增加
* bg.exists 查询元素是否存在

### 漏斗限流
* 使用redis-cell限流, 原子

### GeoHash
* 用于地理位置排序查找
* 将二维的经纬度数据映射到一维的整数
* geoadd 添加名称, 经纬度三元组
* geodist 计算两个元素之间距离
* geopos 获取任务元素的经纬度坐标
* georadiusbymember 查询指定元素附近其他元素
* georadius 查询指定坐标附近的其他元素

### 搜索key
#### key [正则]
* 获取所有符合正则的key
* O(n)复杂度, 会阻塞Redis服务
* 无法指定指定offset, limit

#### scan [正则]
* 获取所有符合正则的key
* O(n)复杂度, 但是通过游标分布进行, 不会阻塞线程
* 服务器不保存游标状态, 由scan返回给客户端维护
* 返回的结果可能会有重复, 需要去重
* 返回的游标值为0表示遍历结束
* 采用`高位进位法`遍历, 为了考虑字典的扩容和缩容

### 管道
本质是客户端通过改变了读写的顺序带来性能的巨大提升

## RESP
RESP是Redis序列化协议的简写. 是一种直观的文本协议, 又是子啊与实现异常简单, 解析性能极好
* 单行字符串以`+`开头
* 多行字符串以`$`开头, 后跟字符串长度
* 整数值以`:`卡头, 后跟整数的字符串形式
* 错误信息以`-`开头
* 数组以`*`开头, 后跟数组的长度

## 持久化机制
### 快照
* 全量备份
* 二进制
* 使用COW机制备份(fork)

### AOF日志
* 记录堆内存进行修改的指令记录
* 重放慢
* bgrewriteaof可对AOF日志进行瘦身
> fsync可将指定文件的内容强制从内核缓存刷到磁盘
> redis主节点一般不会进行持久化，主要由从节点进行

### 混合持久化
存储从持久化开始到持久化结束的增量AOF日志和rdb文件

## 事务
* multi
* exec
* discard
> watch机制提供乐观锁

## 主从同步
* C-Consistent 一致性
* A-Availability 可用性
* P-Partition tolerance 分区容性
> Redis保证`最终一致性`

## 集群
* `Redis Sentinal`着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
* `Redis Cluster`着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。


# 智能指针

C++11 引入了 3 个智能指针类型：

* `std::unique_ptr<T>` ：独占资源所有权的指针。
*  `std::shared_ptr<T>` ：共享资源所有权的指针。
* `std::weak_ptr<T>` ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。

## 初始化方式
以std::shared_ptr为例
### 构造函数初始化
```C++
//普通构造
std::shared_ptr<int> pointer(new int(1));
//拷贝构造
std::shared_ptr<int> pointer1 = pointer;
//别名构造
auto elts = {0, 1, 2, 3, 4};
std::shared_ptr<Vec> pvec = std::make_shared<Vec>(elts);
return std::shared_ptr<int>(pvec, &(*pvec)[2]);

```

### std::make_shared初始化
```C++
std::shared_ptr<string> p3 = std::make_shared<string>();

std::shared_ptr<string> p2 = std::make_shared<string>("hello");
```

### reset初始化 
```C++
std::shared_ptr<int> pointer = nullptr;
pointer.reset(new int(1));
```


## std::unique_ptr
* 独占资源
* 离开 unique_ptr 对象的作用域时，会自动释放资源，这是很基本的 RAII 思想
* 可以自定义deleter

```C++
//std::unique_ptr 是 move-only 的。
    std::unique_ptr<int> uptr = std::make_unique<int>(200);
    std::unique_ptr<int> uptr1 = uptr;  // 编译错误，

    std::unique_ptr<int> uptr2 = std::move(uptr);
    assert(uptr == nullptr);

// std::unique_ptr 可以指向一个数组。
    std::unique_ptr<int[]> uptr = std::make_unique<int[]>(10);

//自定义 deleter。
    struct FileCloser {
        void operator()(FILE* fp) const {
            if (fp != nullptr)  fclose(fp);
        }   
    };  
    std::unique_ptr<FILE, FileCloser> uptr(fopen("test_file.txt", "w"));
}

//使用 Lambda 的 deleter。
{
    std::unique_ptr<FILE, std::function<void(FILE*)>> uptr(
        fopen("test_file.txt", "w"), [](FILE* fp) {
            fclose(fp);
        });
}
```

## std::shared_ptr
* 对资源做引用计数
    * 每次有新的shared_ptr指向资源, 引用+1
    * shared_ptr析构时,引用-1
    * 引用计数为0时, 释放资源
* 可以自定义deleter

```C++
    //指向数组
    std::shared_ptr<int[]> sptr = std::make_shared<int[]>(100);
    //直接初始化
    std::shared_ptr<int[]> sptr(new int[10]);

```

### aliasing constructor(别名构造函数)

```C++
template< class Y >
shared_ptr( const shared_ptr<Y>& r, element_type* ptr ) noexcept;
```
相当于智能指针的别名(指向类型不同)

![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211041442304.png)
`问`:对象的成员和对象本身,显然的确应该共享生存期,但有人可能会问了, 为什么不用->调用成员呢,
`答`:比如以下情况

```C++
struct Base1 { int base1=0; };   
struct Base2 { int base2=0; };   
struct A:Base1,Base2{};    

int main()
{
    auto ptr = new A;     

        shared_ptr<Base1>ptr1 ((Base1*)ptr);    
        shared_ptr<Base2>ptr2 ((Base2*)ptr);    
        //内存泄漏,ptr2已经被释放:-572662307end crash     
        
        shared_ptr<Base2>ptr2(ptr1, (Base2*)(ptr));    
        //化名,ptr2未被释放:0end    
        
        ptr1.reset();    
        cout << ptr2->base2;    

    return 0;    

}  
```
在C++中,一种特殊的情况在于多继承, 当我们面向接口(类型)编程时, 如果我们使用接口指针去操纵对象,就不得不遇到不同接口的智能指针指向同一个对象了. 一旦我们没有使用Alias, 由于不同类型指针无法共享控制块, 这势必会产生内存泄漏, 而通过Alias, 我们则完美地避免了这一情况.

## std::weak_ptr
* 需要与std::share_ptr一起使用
* 不影响托管对象的生命周期
* 可通过lock(原子操作)提升为shared_ptr
* 当托管对象被释放时, weak_ptr等同于null_ptr


## 循环引用问题本质
shared_ptr的析构依赖于托管对象的析构
```C++
class ShardPtrTest
{
public:
    std::shared_ptr<ShardPtrTest> ptr;
};

void test_shard_ptr()
{
    auto ptr = std::make_shared<ShardPtrTest>();
    ptr->ptr = ptr;//ptr->ptr此处依赖了ptr的析构
}
```

## shared_ptr实现原理

![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211041413733.jpg)

需要维护的信息有两部分

* 指向存储的指针
* 指向引用计数等控制信息的`控制块`指针`_M_refcount`


![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211012229961.png)

> deleter 是保存在控制信息中，所以是否有自定义 deleter 不影响 shared_ptr 对象的大小

复制一个shard_ptr
    `std::shared_ptr<T> sptr2 = sptr1;`

![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211012234614.png)
`问`:为什么控制块和每个 shared_ptr 对象都需要保存指向共享资源的指针？可不可以去掉 shared_ptr 对象中指向共享资源的指针，以节省内存开销？
`答`:内部控制块的模板参数和外部智能指针的模板参数毫无干系, 因此控制块指针和存储指针本质上是完全独立的(别名构造因此实现)
### 托管对象的生命周期
* shared_ptr拷贝时_M_use_count加1
* weak_ptr lock升级为shared_ptr时, _M_use_count加1
* shared_ptr析构时_M_use_count减1
* 当_M_use_count为0时，表示不再需要管理`共享资源`，调用__M_dispose()来释放`共享资源`内存。
> 释放`共享资源`内存时, 会通过`控制块`内的指针来释放

### 管理对象的生命周期
* weak_ptr或shared_ptr拷贝时_M_weak_count加1
* weak_ptr或shared_ptr析构时_M_weak_count减1
* 当_M_weak_count为0时，表示不再需要`控制块`来控制共享资源，调用_M_destroy()来释放`控制块`内存。


### 线程安全
* 单个线程读写单个shareptr ok
* 多个线程读单个shareptr ok
* 多个线程分别读写指向同一管理块的sahreptr ok
* 多个线程读写单个shareptr 有线程安全问题
    * 指针赋值和计数自增不是原子的

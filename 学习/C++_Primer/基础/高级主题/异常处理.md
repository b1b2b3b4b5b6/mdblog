# 异常处理
## throw 
* throw语句中的表达式必须拥有完全类型
* 表达式的静态编译时类型决定了异常对象的类型（解引用基类指针，只会截取基类部分）
* throw会拷贝异常对象至编译器管理的空间中
* 在catch内调用空throw可以重新抛出异常
> catch外的空throw会直接terminate程序

## catch
* 声明的类型决定了处理代码所能捕获的异常类型，必须是完全类型
* 声明的类型不能是右值引用
* 匹配第一个符合条件catch
* 匹配转换
    * 非常量到常量的转换
    * 派生类到基类的转换
    * 数组到指向数组类型的指针
    * 函数到指向函数类型的指针
* `catch(...)`捕获所有异常


## try
构造函数内的try管不到初始化列表，需要将构造函数写成`函数try语句块`，如下
```C++
class A {
public:
  BASE base;
  A(BASE in_a) try : base(in_a) { cout << "a normal" << endl; } catch (...) {
  }
};
```


## 栈展开
* 暂停当前函数的执行过程
* 寻找包含throw最近的try语句，判断catch子句是否匹配
    * 匹配则执行catch子句代码
        * 沿着调用链退出函数，并销毁调用链创建的对象
        * 执行catch子句并销毁异常对象
        * 继续执行
    * 不匹配则继续查找更外层try语句
* 找不到terminate程序
   
> 由于析构函数会在栈展开时调用，故不能让析构函数抛出异常，否则会直接terminate程序

## noexcept异常说明
```C++
void foo() noexcept;//不会抛出异常
void foo() noexcept(true);//不会抛出异常
void fooo() noexcept(false); //可能抛出异常
void f() noexcept(noexcept(foo())); //f和foo的异常说明一致
```
* 编译器不会检查noexcept说明
* noexcept函数抛出异常时，直接terminate程序
* 可以增加bool实参，代表是否会noexcept
* noexcept不属于函数类型的一部分，但是会影响函数的使用
    * 函数指针指向
    * 虚函数派生
    * 合成拷贝控制成员，合成析构

### noexcept运算符
* 当作noexcept异常说明的bool实参出现时，当作运算符

## 异常类层次
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211211503980.png)
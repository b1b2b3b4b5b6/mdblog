# 基础

## 泛泛
- 通过**调用运算符**`()`来执行函数
- 只存在与块执行期间的对象称作**自动对象**

## 函数的定义
包括以下4个要素
- 返回类型
- 函数名字
- 0个或多个形参组成的列表
- 函数体
函数只能定义一次,但可以声明多次,声明可以不写形参名

### 形参
#### 传递类型
形参的初始化机理与变量初始化一样
- 当形参是引用类型时,对应的实参被**引用传递**
- 当实参的值被拷贝给形参时,对应的实参被**值传递**
- C++没有规定实参的求值顺序, 由编译器自己决定

#### 数组形参
- 数组无法以值传递的方式使用,会被转换成指针
- 数组引用形参的维度必须写,如下

```C++
void foo(int (&arr)[10])
{
}
```
- 多维数组可以不写第一个维度(写了也会被忽略)

```C++
void foo(int (&arr)[][10])
{
}
```

#### initialzer_list形参
标准库类型,表示某种特定类型的值的数组,如下

```C++
void error_msg(initializer_list<string> il)
{
    for(auto beg = il.begin(); beg != il.end(); ++beg)
        count << *beg << " ";
}
string my_string = "asf";
error_msg({"123", "asfsf", my_string});
```
> 使用时必须将序列放在一对花括号内

| 用法                     | 含义                        |
| :----------------------- | :-------------------------- |
| initializer_list<T> lst | 默认初始化T类型元素的空列表 |
| initializer_list<T> lst{a,b,c...} | 元素数量如列表,但都是副本,且为const |
| lst2(lst);lst2=lst                 | 拷贝或复制一个initializer_list对象到lst2,但是共享元素|
| lst.size()                     | 元素数量                        |
| lst.begin()                     | 首元素的指针                        |
| lst.end()                     | 尾元素的下一位置的指针                        |

### 返回类型
- 返回类型不能是数组类型或函数类型
- 调用一个返回引用的函数得到**左值**, 其他返回类型得到**右值**
- 列表初始化`{a,b,c}`也可作为返回值
- 可以使用`尾置返回类型`
    ```C++
    auto func(int i) -> int(*)[10];
    auto func(int i) -> decltype(i);
    ```
    >尾置返回出现在参数列表之后，故可以使用函数的参数


- 或者decltype

```C++
int odd[] = {1,2,3,4};
decltype(odd) *arrPtr(int i )
{
    return &odd;
}
```
> decltype不会将数组类型转成对应的指针 所以arrPtr前必须加*解引用


## 函数重载
匹配优先级
* 精确匹配
    * 实参类型和形参类型相同
    * 实参从数组类型或函数类型转换成对应的指针类型
    * 向实参添加顶层const或从实参中删除顶层const
* 通过const转换实现的匹配
* 通过类型提升实现的匹配
* 通过算数类型转换实现的匹配
* 通过类类型转换实现的匹配

## 函数指针
* 把一个函数名作为值使用时,该函数自动地转换成指针
* 编译器通过指针类型决定算用那个函数, 必须**精确匹配**
* 定义**函数指针形参**时, 可以不加*, 如下

```c++
void foo()
{}

void foo2(void foo())
{}
```
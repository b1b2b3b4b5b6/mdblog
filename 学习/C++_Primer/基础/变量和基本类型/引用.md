# 引用

- 引用是对象的别名
- 引用必须被初始化(无法重新绑定到另外一个对象)
- 分为左值引用和右值引用

## 左值引用

```C++
int i = 42;
int &r = i;        
const int &r2 = i*42; //正确,const int 的引用
int const &r3 = i*42; //正确,int 的 const引用
```
* 绑定到左值上
* const类型的引用和类型的const引用可以绑定到右值(或无法更改的值)


## 右值引用

```C++
int i = 0;
int &&rr = 1+2;        //正确
int &&rr2 = i;        //错误，右值引用不能绑定到左值上
```
* 绑定到右值上
    * 返回非引用的函数
    * 算数,关系,位,后置递增/递减运算符

## 引用折叠
通常情况下，无法定义引用的引用，但是对于**类型别名**或**模板参数**，可以定义
* `X& &`,`X& &&`,`X&& &`都折叠成类型`X&`
* 类型`X&& &&`折叠成`X&&`

## move
用法如下

```C++
int i = 0;
int &&r = std::move(i);
```

* 可以显式的将左值转换为对应的右值引用类型
* move应使用std::move,避免潜在冲突


## forward
std::forward源码如下
```C++
template <typename T>
T&& forward(typename std::remove_reference<T>::type& param)
{
    return static_cast<T&&>(param);
}

template <typename T>
T&& forward(typename std::remove_reference<T>::type&& param)
{
    return static_cast<T&&>(param);
}
```
作用是
得到和入参类型一致的输出

## 完美转发
搭配万能引用(&&), 引用折叠, std::forward, 可以实现完美转发,即
将函数原始入参类型转发到另一个函数的入参, 如下
```C++
void testForward(T && v){
    print(std::forward<T>(v));
}
```
上述print入参类型与testForward完全一致


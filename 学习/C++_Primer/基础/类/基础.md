# 基础

## 类的定义
包含类头和类体

## 类的声明
* 声明类而不定义它,称为**前向声明**
* 前向声明的类型是**不完全类型**
## 类成员
* 定义在类内部的函数是内联(inline)的,否则是外联的
* 对类成员提供类内初始值时,必须以符号`=`或`花括号`表示

### this
* 是**指向非常量的常量指针**,故不能在常量对象上调用普通的成员函数
* 可以在成员函数的形参列表后增加`const`,说明this指向常量,如下

```C++
int my_foo() const {
    return 0;
}
```
> 这样的函数叫做**常量成员函数**

### 可变数据成员(mutable)
* 可变数据成员永远不会是const,即使它是const对象的成员,如下
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202110061953976.png)


## 构造函数
* 构造函数的名字和类名相同,但是没有返回类型
* 构造函数不能被声明成const(类直到构造函数完成初始化过程,才能获得其**常量**属性)

### 默认构造函数
* 默认构造函数没有任何形参
* 如果没有显示的定义任何构造函数,则编译器会创建**合成默认构造函数**,其初始化类数据规则如下
    * 如果存在类内的初始值,用它来初始化成员
    * 否则,默认初始化该成员
* 通过如`my_ins() = default`可以显示要求编译生成合成默认构造函数
> 成员必须被初始化时(const,引用,无默认构造), 则需要显式初始化
### 构造函数初始值列表
如下, `m_a(a), m_b(b)`是构造函数初始化列表

```C++
class my_class{
    int m_a;
    int m_b;
    my_cal(int a, int b): m_a(a), m_b(b){
        
    };
};
```
* 没有出现在构造函数初始值列表将通过相应的类内初始值(如果存在),或者执行默认初始化
* 成员的初始化顺序与他们在类定义中出现的顺序一致
* 一般调用拷贝构造函数，并在构造函数之前执行

### 委托构造函数
形如

```C++
class my_class{
    my_init(int a, int b, int c):m_a(a), m_b(b), m_c(c) {}
    my_init_1(): my_init(0,0,0) {};
    my_init_2(int a): my_init(a, 0, 0)();
}
```
`my_init_1`和`my_init_2`是委托构造函数

## 访问控制
* 一个类可以包含0个或多个访问说明符(private, public)
* 其有效范围知道下个访问说明符或者类的结尾处为止

### 访问修饰符
* `public`用户可以访问
* `protected`用户不可访问,派生类内可访问
* `private`用户不可访问

> 成员和友元始终可以访问所有成员

### class和struct的区别
* class默认访问权限为**private**,private继承
* struct默认访问权限为**public**,public继承

### 友元
* 友元不是类的成员,也不受访问控制级别的约束
* 友元声明只能出现在类定义的内部
* 友元函数必须在使用之前,在类的外部声明(有些编译器支持)
* 友元函数或友元类可以访问所有类成员
* 友元关系无法传递

### 作用域
* 编译器处理完类中的全部声明后, 才会处理成员函数的定义
* 在类中,如果使用了外层作用域的类型名,则此类不能重新定义该名字
* 成员函数中使用的名字按照以下方式解析
    * 在成员函数类查找
    * 在类内查找
    * 该成员函数定义之前的作用域查找
> 外层被隐藏的对象可以用作用域运算符访问

## 转换构造函数
只接受一个实参的构造函数称为**转换构造函数**
* 隐式转换依赖转换构造函数

### explicit
* 将构造函数声明为explicit可以抑制隐式转换,如下

```c++
explicit my_init(int a){};
```
* explicit只对转换构造函数有效
* explicit只能在类内使用,内外不应重复
* explicit构造函数只能用于直接初始化
* 可以用`static_cast`显示转换来进行强制转换,如下

```C++
static_cast<my_class>(3);
```

## 聚合类
定义如下:
* 所有成员都是public
* 没有定义任何构造函数
* 没有类内初始值
* 没有基类和virtual函数
可以对聚合类使用列表初始化,如下

```C++
data val = {0, "asfd"};
```
要注意**初始值的顺序必须与声明的顺序一致**
如果初始值列表的元素个数少于类的成员个数,则靠后的成员被默认初始化

## 字面值常量类
定义如下
* 数据成员都是字面值类型
* 类至少含有一个constexpr构造函数(一般为空)
* 类使用析构函数的默认定义

## 类的静态成员(static)
* 静态成员不能声明成const
* 不能在static函数体内使用this指针(静态成员存在与任何对象之外)
* static关键字无法在类内和类外重复
* 不能在类内初始化，但可以通过constexpr修改并赋常量表达式来类内初始化
    ```C++
    class SinFoo
    {
    public:
       constexpr static int a = 0; //类内static初始化
    };
    ```
* 在类外初始化
    ```C++
    int SinFoo::a = 0; //类外初始化
    ```

### 静态成员和普通成员的区别
* 静态成员可以是不完全类型

```C++
class Bar{
pubic:
    static Bar mem1;  //正确:静态成员可以是不完全类型
    Bar *mem2;        //正确:指针成员可以是不完全类型
    Bar mem3;         //错误:数据成员必须是完整类型
}
```
* 可以使用静态成员作为默认实参


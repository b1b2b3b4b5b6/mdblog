# 进程管理
## 总览
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211221047463.png)

## 进程模型
### 进程控制块(PCB)
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211221049540.png)
* 创建PCB时间点
    * 系统初始化
    * 用户通过api创建新进程
    * 批处理作业初始化
    * 由现有进程派生子进程
* 进程初始化
    * 给进程分配进程ID
    * 分配内存空间
    * 初始化PCB
    * 进入就绪队列

### 进程状态模型

![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211211719943.png)
> 挂起会将进程交换到磁盘

* 僵尸进程
    * 僵尸状态是一个比较特殊的状态，当进程退出并且父进程没用读取到子进程的退出码时，就会产生僵尸状态
    * 僵尸进程会以终止状态保持在进程表中，并且一直等待父进程读取退出状态代码
* 孤儿进程
    * 父进程如果提前退出，子进程就会成为孤儿进程，孤儿进程会被1号init进程领养


## 线程模型
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211221112036.png)
### 为何需要多线程
* I/O密集型有优势
* 线程间共享该进程的内存和文件，不需要内核调用


## 任务调度
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211221114149.png)
### 上下文切换
* 保存处理器上下文环境：将CPU程序计数器和寄存器的值保存到当前进程的私有堆栈里
* 更新当前进程的PCB（包括状态更变）
* 将当前进程移到就绪队列或者阻塞队列
* 根据调度算法，选择就绪队列中一个合适的新进程，将其更改为运行态
* 更新内存管理的数据结构
* 新进程内对堆栈所保存的上下文信息载入到CPU的寄存器和程序计数器，占有CPU

### 调度模型
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211221115440.png)

### 调度算法
* 先来先服服务
* 时间片轮转
* 最短作业优先
* 最短剩余时间优先
* 优先级调度
* 多级反馈队列调度

## 进程间通讯
* 共享内存
* 管道
* 消息
* 信号量
* 信息

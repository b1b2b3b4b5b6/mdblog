# 面试点
### extern "C"
*  #include <typeinfo>int n;std::cout << typeid(n).name() << std::endl; //输出n类型字符C++
* 告诉C++编译器在链接时是使用C的符号规则,否则会链接不到C写的函数，或则C无法链接到C++写的函数
    * C编译生成的符号不包含参数类型
    * C++为了支持重载, 符号包含参数类型
> extern "C"只影响函数重载, 不影响其他特性 

### RAII
充分利用C++局部对象自动销毁的特性来控制资源的声明周期

* 设计一个类封装资源
* 在构造函数中初始化
* 在析构函数中执行销毁操作
* 使用时声明一个该对象的类

### new[]与delete[]的使用
* new[]会申请K*N个空间,并且在头部申请4个字节存储K
* delete[]根据头部的K调用析构释放
* 如果是内置类型,没有析构,则可以用delete释放
> delete类指针会调用析构, 所以析构需要定义成虚函数

### volatile
* 编译器对访问变量的代码不再进行优化
    * 阻止编译器缓存到寄存器而不会写回
    * 阻止编译调整操作变量的指令顺序(无法阻止cpu的动态执行)
* 编译器总是从原始地址读数据
* 可以和const共存


![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202211181354125.png)

例如："一个离线数据处理程序，运行起来会崩溃，你会如何处理这个问题。"这里是从捕获，跟踪，定位，解决问题来观察面试者是否有经验，而前三者是重点。涉及到如何有效地复现问题，如何快速地找到暴露问题的代码，如何跟踪到问题起因的代码。通常解决问题是最容易的。也涉及到一些工具如动态挂载debugger，或者放dump点用postmortem debugging来定位暴露问题的点，会不会查看call stack，找株连问题的起点。
"一个在线服务程序，QPS很低，你会如何处理这个问题。"要求面试者知晓操作系统底层组件的性能假设，找到性能的瓶颈。由外而内从系统资源监视器入手，或由内而外使用profiling工具入手都可以。能够理清是什么层面的问题，涉及到什么资源等。这些是通用手段。针对特定问题，比如，如果可以讨论到OS所提供的各种I/O模型，同步原语，及其优劣和相关的开销那就更好了。
这种类似的问题组合起来可以有很多，从一开始问题的现象，最终落实到诸如多核计算、内存/缓存、网络I/O、磁盘I/O、同步原语、OS内核资源等方面的问题。不仅仅要知道哪些系统调用的逻辑是什么，背后的机制是什么，还需要明白调用的开销是什么，副作用是什么。这个部分的面试是个交互过程，一开始问题的定义都是模糊的，面试者可以来回问我，细化问题的具体情况和所处的具体场景。考察得不仅仅是C++及系统相关技术，同时也包含分析以及处理问题的能力和思维方式以及实战经验。
# 编译符号导出规则


## 测试环境
* clang
* O0优化
* 使static变量被直接或间接使用，不然编译会忽略此static变量
* 不考虑命名空间
* `objdump -t` 导出 `.o`文件

## 符号类型(定义)
此处讨论的符号不包含static修饰的变量或符号, 因为不会参与链接决议
有符号必然有地址(`.rodata` `.data` `.bss`)
### 强符号
* 默认定义的全局变量或和函数是强符号
* 链接时不允许有同名的的强符号
### 弱符号
* 使用`__attribute__((weak))`修饰的全局变量或函数为弱符号
* 使用inline修饰的全局变量或函数(前提是会参与链接)
* 链接允许有同名的弱符号, 并以占用空间最大的符号(如果是变量)为准

### 引用类型(声明)
### 强引用
* 默认声明的全局变量或和函数是强引用
* 链接时必须能找到此符号
### 弱引用
* 使用`__attribute__((weakref("targetRef")))`或`__attribute__((weak)) extern`修饰的全局变量或函数声明为弱符号
* 链接时允许找不到符号, 运行时会发生非法访问地址错误
> `targetRef`是引用的符号名, 被修饰的声明可以和引用名不一样
```C++
__attribute__((weak)) extern int _ZL2kk;
static __attribute__((weakref("_ZL2kk"))) int hhh;
```

## 变量编译时导出的符号
| 定义名 |   变量类型   |      符号名      | 符号类型 |
| ------ | ------------ | --------------- | -------- |
| k      | 全局变量     | k               | global   |
| wk    | 全局变量(弱符号) | wk | weak    |
| kk     | 全局静态变量 |          _ZL2kk       |  local        |
| kkk    | 局部静态变量 | _ZZL4testvE3kkk | local    |
> 有趣的是, 在clang环境下,如果两个变量的符号名完全一致时(符号类型不一致), 那编译时导出的符号只有一份, 以定义的先后顺序, 后面会覆盖前面的, 导致事实上两个变量定义使用的是同一个内存! 不过在gcc环境下, 会报多重定义错误

## 链接规则
* 链接后, 重名符号只保留一个, 且维持符号类型

## lamda
* 定义lamda对象时, 对象遵循上面的符号导出规则
* lamda的重载的`()`成员函数导出为位于`text`段的`local`类型符号, 符号名称按一定规则变化递增

## 类内成员函数定义
* 默认带有inline修饰(无论是否带有static修饰)

## 函数模板
* 默认带有inline修饰

## 类模板
* 实例的成员函数带有给inline修饰
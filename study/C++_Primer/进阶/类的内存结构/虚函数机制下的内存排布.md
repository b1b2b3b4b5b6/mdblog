# 虚函数机制下的内存排布

```cpp
/*
*** Dumping AST Record Layout
         0 | class VBASE
         0 |   (VBASE vtable pointer)
         8 |   int vbase
           | [sizeof=16, dsize=12, align=8,
           |  nvsize=12, nvalign=8]
*/
class VBASE {
  int vbase = 10;
  virtual void foo(){};
};
auto vbase = VBASE();
/*
*** Dumping AST Record Layout
         0 | class BASE
         0 |   int base
           | [sizeof=4, dsize=4, align=4,
           |  nvsize=4, nvalign=4]
*/
class BASE {
  int base = 10;
};
auto base = BASE();
/*
*** Dumping AST Record Layout
         0 | class A_BASE
         0 |   class BASE (base)
         0 |     int base
         4 |   int a_base
           | [sizeof=8, dsize=8, align=4,
           |  nvsize=8, nvalign=4]
*/
class A_BASE : BASE {
  int a_base = 10;
};
auto a_base = A_BASE();
/*
*** Dumping AST Record Layout
         0 | class B_BASE
         0 |   class BASE (base)
         0 |     int base
         4 |   int b_base
           | [sizeof=8, dsize=8, align=4,
           |  nvsize=8, nvalign=4]
*/
class B_BASE : BASE {
  int b_base = 10;
};
auto b_base = B_BASE();
/*
*** Dumping AST Record Layout
         0 | class A_VBASE
         0 |   class VBASE (primary base)
         0 |     (VBASE vtable pointer)
         8 |     int vbase
        12 |   int a_vbase
           | [sizeof=16, dsize=16, align=8,
           |  nvsize=16, nvalign=8]
*/
class A_VBASE : VBASE {
  int a_vbase = 10;
};
auto a_vbase = A_VBASE();
/*
*** Dumping AST Record Layout
         0 | class B_VBASE
         0 |   class VBASE (primary base)
         0 |     (VBASE vtable pointer)
         8 |     int vbase
        12 |   int b_vbase
           | [sizeof=16, dsize=16, align=8,
           |  nvsize=16, nvalign=8]
*/
class B_VBASE : VBASE {
  int b_vbase = 10;
};
auto b_vbase = B_VBASE();
/*
*** Dumping AST Record Layout
         0 | class C_AB_BASE
         0 |   class A_BASE (base)
         0 |     class BASE (base)
         0 |       int base
         4 |     int a_base
         8 |   class B_BASE (base)
         8 |     class BASE (base)
         8 |       int base
        12 |     int b_base
        16 |   int c_ab_base
           | [sizeof=20, dsize=20, align=4,
           |  nvsize=20, nvalign=4]
*/
class C_AB_BASE : A_BASE, B_BASE {
  int c_ab_base = 10;
};
auto c_ab_base = C_AB_BASE();
/*
*** Dumping AST Record Layout
         0 | class C_AB_VBASE
         0 |   class A_VBASE (primary base)
         0 |     class VBASE (primary base)
         0 |       (VBASE vtable pointer)
         8 |       int vbase
        12 |     int a_vbase
        16 |   class B_VBASE (base)
        16 |     class VBASE (primary base)
        16 |       (VBASE vtable pointer)
        24 |       int vbase
        28 |     int b_vbase
        32 |   int c_ab_vbase
           | [sizeof=40, dsize=36, align=8,
           |  nvsize=36, nvalign=8]
*/
class C_AB_VBASE : A_VBASE, B_VBASE {
  int c_ab_vbase = 10;
};
auto c_ab_vbase = C_AB_VBASE();
```


## 内存排布
* 先将基类类依次排布
    * 优先放置多态基类
* 含有virtual成员函数
    * 如果头部无预留虚函数表指针空间，则新增

## 成员函数调用流程（编译期决定）
### 非虚函数
* 非静态成员函数带有隐含形参`BASE * const this`, 在调用时，结合函数地址，对象地址（如果调用父类的成员函数，则需要编译器调整this指针至实际父类内存位置），其他实参完成调用
* 静态成员数无隐含形参`BASE * const this`
> 如果成员函数不解引用this，则通过指针强转成员函数也可以正常运行
### 虚函数
* 每种多态类都有自己的虚函数表（可以多个），写死在.rodata中，并将其地址写死在指向虚函数表的指针空间中
    * 如果是单继承，那只有一个虚函数表
    * 如果是多继承，则会有多个虚函数表，第一个虚函数表为主表，放置子类独有的虚函数
    * 如果父类有多个虚函数表，则子类也会有多个虚函数表
* 对于子类和父类来说，虚函数是通过虚函数表来找到函数地址
    * 如果调用父类的成员函数，this指针需要调整至实际父类内存位置
    * 通过虚函数表指针获得虚函数表
    * 相同的函数符号使用相同的表内偏移
    * 获得函数地址
* 后续步骤于与虚函数流程相同


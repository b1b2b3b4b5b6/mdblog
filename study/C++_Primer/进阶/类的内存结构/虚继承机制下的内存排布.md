# 虚继承机制下的内存排布
```C++
/*
*** Dumping AST Record Layout
         0 | class BASE
         0 |   int base
           | [sizeof=4, dsize=4, align=4,
           |  nvsize=4, nvalign=4]
*/
class BASE {
public:
  int base = 7;
};
auto base = BASE();
/*
*** Dumping AST Record Layout
         0 | class AV_BASE
         0 |   (AV_BASE vtable pointer)
         8 |   int av_base
        12 |   class BASE (virtual base)
        12 |     int base
           | [sizeof=16, dsize=16, align=8,
           |  nvsize=12, nvalign=8]
*/
class AV_BASE : public virtual BASE {
public:
  int av_base = 8;
};
auto av_base = AV_BASE();
/*
*** Dumping AST Record Layout
         0 | class CV_AV_BASE
         0 |   (CV_AV_BASE vtable pointer)
         8 |   int cv_av_base
        28 |   class BASE (virtual base)
        28 |     int base
        16 |   class AV_BASE (virtual base)
        16 |     (AV_BASE vtable pointer)
        24 |     int av_base
           | [sizeof=32, dsize=32, align=8,
           |  nvsize=12, nvalign=8]
*/
class CV_AV_BASE : public virtual AV_BASE {
public:
  int cv_av_base = 9;
};
auto cv_av_base = CV_AV_BASE();
/*
*** Dumping AST Record Layout
         0 | class DV_CV_AV_BASE
         0 |   (DV_CV_AV_BASE vtable pointer)
         8 |   int dv_cv_av_base
        44 |   class BASE (virtual base)
        44 |     int base
        32 |   class AV_BASE (virtual base)
        32 |     (AV_BASE vtable pointer)
        40 |     int av_base
        16 |   class CV_AV_BASE (virtual base)
        16 |     (CV_AV_BASE vtable pointer)
        24 |     int cv_av_base
           | [sizeof=48, dsize=48, align=8,
           |  nvsize=12, nvalign=8]
*/
class DV_CV_AV_BASE : public virtual CV_AV_BASE {
public:
  int dv_cv_av_base = 10;
};
auto dv_cv_av_base = DV_CV_AV_BASE();
```

## 概念
* 愿意共享虚继承的基类，意味着无论虚基类在派生体系中出现了几次，都只包含一个虚基类的成员
* 只影响从从虚基类派生类派生出来的类
* 最终派生类调用虚基类的构造函数初始化虚基类
* 构造时先调用虚基类的构造函数

## 内存排布
* 先将基类依次排布
* 整体抽取直接基类的虚基类到内存末端（如果已有不新增）
* 直接基类如果是虚继承
    * 将直接基类移至内存末端


## 成员变量访问流程
### 非虚继承父类的成员变量
* 直接根据this（需要经过编译器调整以指向父类实际内存位置）+成员变量的类内偏移量获得实际地址来访问
### 虚继承父类的成员变量
* 虚继承父类的子类必然会在头部预留虚基类表指针空间，虚基类表写死在.rodata中，并将其地址写死在虚基类表指针空间中
    * 如果父类也有虚基类表指针，则其指向的虚基类表是根据当前类的内存结构定的，故每种类及其内部的多个虚基类表指针都是独一无二的，其指向的虚基类表同理
* 子类通过虚基类表获得父类内存起始地址
    * 包含有同一虚基类的派生类，按照相同的偏移在虚基类表寻找父类地址，即 父类符号-虚基类表内偏移 在编译期固定

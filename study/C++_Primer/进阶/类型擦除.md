# 类型擦除
​


## 什么是类型擦除(Type Erasure)

首先还是回到类型擦除是什么的问题，类型擦除(Type Erasure)顾名思义就是把类型信息擦除，这种代码可以处理来自多个类或模板的对象，而不需要知道即将对其操作的对象的类型是什么。
类型擦除主要用于泛型编程，可以编写出能接受任意类型参数的函数和类，只要它们提供了你需要的操作，这意味着只需要关心它的行为即可，而不用在意其具体实现。主要用途如下所示：

*   隐藏具体类型信息
*   统一不同类型的接口
*   实现泛型容器
## 各种实现
### 基于void*的实现

首先void_是支持转换到任何类型，那也就是说void_意味着一个固定大小的指针，它可以指向任何类型的对象，但是并不知道它指向的对象的实际类型。这实际上已经擦除了类型信息。所以void_是一种相当早期的类型擦除的用法了。由于擦除了类型因此在对void_进行操作之前，通常需要将其转换回其原始类型，否则无法对其进行有意义的操作。最显著的例子那就是qsort的实现，qsort函数的声明如下：

```cpp
void qsort(void *__base, size_t __nel, size_t __width,
        int (* _Nonnull __compar)(const void *, const void *));
```

qsort 就通过void\*实现的类型擦除，qsort是一个通用的排序函数，它可以对任何类型的数组进行排序。qsort函数接受一个void类型的指针，表示待排序的数组，以及一个用于比较数组元素的函数指针。compare函数也接收两个void参数，然后将这两个void转换回实际的int类型，以便比较整数值。

但是现代C++编程中并不建议使用void\*来实现类型擦除，如下所示：

*   类型安全：void_在编译时无法执行类型检查。当尝试将void_转换回其原始类型时，编译器无法检查你是否转换为正确类型。这意味着如果犯了错误，你可能不会在编译时发现，而只会在运行时以一种常常难以诊断的方式出现问题。
*   可读性：使用void\*往往会使代码更难以理解，因为它隐藏了类型信息。这使得阅读和理解代码需要更多的上下文。
*   容易出问题：直接操作裸指针是十分危险的，对其的误操作(如错误的类型转换)可能会引发严重的运行时错误，这对于调试非常不利。

所以在现代C++编程中，一般不使用void\*的方案，后续有更多方案既可以保证类型安全又保证了代码可读性。

### 基于虚函数的实现

当然也可以用面对对象思想的方式来实现，面对对象的三大特性封装、继承、多态。这里就可以通过多态来实现。而多态是通过虚函数和抽象基类配合来实现的，多态允许通过父类的指针或引用来调用派生类内的具体函数，所以多态本身也就是一种类型擦除，因为在调用函数时不需要知道派生类的类型是怎么样的。但是这个类型并没有完全擦除，因为还必需要知道父类的类型是怎么样的。这里通过SmallCallable内部的实现来举例。如下所示：

```cpp
struct Invokable
{
    virtual ~Invokable() = default;
    virtual R call(Params...) = 0;
    virtual bool active() const = 0;
};

template <typename I>
struct CapturedInvokable final : Invokable
{
    explicit CapturedInvokable(I&& holder_) : holder(std::move(holder_)) {}
    // explicit CapturedInvokable(const I& holder_) : holder(holder_) {}
    R call(Params... params) override { return holder(std::forward<Params>(params)...); };
    bool active() const override { return true; }
    I holder;
};

struct NullInvoker final : Invokable
{
    R call(Params...) override { return R(); }
    bool active() const override { return false; }
};

struct CapturedPlain final : Invokable
{
    explicit CapturedPlain(R (*func_)(Params...)) : func(func_) {}
    R call(Params... params) override { return func(std::forward<Params>(params)...); }
    bool active() const override { return func != nullptr; }
    R (*func)(Params...);
};

template <typename T>
struct CapturedMemberFunc final : Invokable
{
    explicit CapturedMemberFunc(T *ptr_, R (T::*func_)(Params...)) : ptr(ptr_), func(func_) {}
    R call(Params... params) override { return (ptr->*func)(std::forward<Params>(params)...); }
    bool active() const override { return ptr != nullptr && func != nullptr; }
    T *ptr;
    R (T::*func)(Params...);
};
```

在这里基类为Invokable，子类分别为CapturedInvokable、NullInvoker 、CapturedPlain 、CapturedMemberFunc分别实现覆盖基类中的call函数，后续只要通过Invokable的指针或引用来调用到派生类的call函数却不需要关心这些派生类的具体类型和实现是怎么样的。

但是使用虚函数来实现的话运行效率相对会更低一点，因为中间还有一层虚表的跳转会损耗部分性能以及使用虚函数会导致有些优化是不可以做的。但是使用虚函数可以提供运行时多态，使得行为可以在运行时决定并且可以动态更改。并且虚函数的实现和后面的实现方式相比来说更加简单易懂。

### 基于std::variant的实现

在上面通过虚函数和继承来实现类型擦除，但是std::variant可以提供一种类型安全并且在编译期的多态方案。首先std::variant可以存储多种类型的对象(类似于union)，并且在运行时选择需要使用的类型。这种能力可以是该变量根据所处环境选择使用不同的类型(某种意义上这就是多态)。具体示例代码如下所示：

```cpp
struct Circle { void draw() const { std::cout << "Circle\n"; } };
struct Square { void draw() const { std::cout << "Square\n"; } };
struct Triangle { void draw() const { std::cout << "Triangle\n"; } };

using Shape = std::variant<Circle, Square, Triangle>;

// 这是一个泛型的可调用对象
struct GenericInvoker
{
    template<typename T>
    void operator()(T& shape) const
    {
        shape.draw();
    }
};

// 一个可以绘制多种形状的函数
void drawShapes(const std::vector<Shape>& shapes)
{
    for (const auto& shape : shapes)
    {
        std::visit(GenericInvoker(), shape);
    }
}

int main() {
    std::vector<Shape> shapes{Circle{}, Square{}, Triangle{}};
    drawShapes(shapes);
    return 0;
}
```

这里有三种类型它们都有同样的draw函数(确定它们的行为)，定义一个std::variant对象可以存放上述的三种类型。再定义一个可调用类GenericInvoker(重载()运算符)，它可以接受任何的对象并调用其draw函数。在drawShapes接受一个std::vector，使用std::visit和GenericInvoker来遍历每一个元素并且调用具体类型的draw函数。在这里无需在意当前对象的具体类型到底是什么，因为隐藏了其类型信息，只需要它们有draw这个行为即可。

这个方案相较于是虚函数来说是类型安全并且在编译期完成无需像虚函数需要多一次跳转的性能损耗。但是同样它也有缺点，首先是必须在编译时就知道std::variant可以存储的所有类型，如果需要增加或者删除某些类型则需要修改大量代码。并且std::variant和union一样都是需要以最大类型的的存储空间，如果备选类型之间大小差异很大，这也可能会有造成内存浪费(虽然虚函数也得多一个指针的消耗，还是得根据具体情况分析)。并且简单的指针或引用访问相比，std::variant 需要借助std::visit或std::get来访问其所持有的值，这种访问方式可能稍显麻烦。

### 基于CRTP的实现

首先介绍一下CRTP，CRTP也就是Curiously Recurring Template Pattern(奇异递归模板模式)，这种方式主要利用了C++的[编译时多态]，是一种元编程技巧。CRTP的基本原理是派生类将自身类型作为基类的模板参数，这样基类就可以了解派生类的信息。而且这个全部是都在编译期完成的，无需再运行时通过虚表的方式进行调用，而是会直接调用派生类的函数。通过CRTP可以在基类中指定一个未被实现的接口，在派生类中再提供具体的实现，这也就是编译期的多态啦。具体的实例代码如下所示：

```cpp
template <typename Derived> 
class Base 
{ 
   public:
   void interface() 
   { 
      static_cast<Derived*>(this)->implementation();
   } 

   void implementation() 
   { 
      std::cout << "Implementation Base" << std::endl; 
   } 
}; 

class Derived : public Base<Derived> 
{ 
   public:
   void implementation() 
   { 
      std::cout << "Implementation Derived" << std::endl; 
   } 
};
```

这里Base类对象调用interface函数时，将this指针强转为指向Derived的指针，后面就可以通过这个指针来调用派生类的implementation函数。因为是 Derived 继承自Base，所以此时 this 其实就是一个 Derived\* 类型的指针，所以强制类型转换是安全的。这样成功实现了编译时的多态。这就利用了模板在编译时期参数就已经确定的特性，在编译时完成多态的调用，避免了虚函数运行时的开销，并且在某些情况下，更能提供灵活性。

首先使用CRTP来实现是编译期多态，无需虚表可以省去一部分的开销。并且CRTP在编译期就确定了会调用到哪个函数，这也更加利于编译器的优化。但是使用了模板就难免有模板的缺点，那就是模板会让编译时间拉长并且增大最后的代码体积，并且模板一旦报错的话，报错信息基本没法看。

### 基于Concept的实现

首先介绍一下Concept是什么，Concept是一个在C++20引入的重要特性。Concept是一种类型约束，它允许你定义一套约束，这套约束表示一个模板参数必须满足的条件，简单来说，Concept就是类型的谓语。也就是说使用的类型必须满足Concept的约束才可以正常使用，否则会在编译时报错。和CRTP的实现一样都是通过模板来实现并且都在编译期完成。具体示例代码如下所示：

```cpp
template<typename T>
concept Printable = requires(T a) {
    { a.print(std::cout) } -> std::same_as<void>;
};

template<Printable T>
void print(const T& t) {
    t.print(std::cout);
}
```

这里定义了名为Printable的Concept，这里面requires关键字后面的括号内表明这个Concept需要的是一个满足某些要求的类型T。首先可以看到下面这个表达式 `{a.print(std::cout) } -> std::same_as<void>;`这表达式实际上就是去检查类型T是否满足这样的要求，也就是它是否有一个名为print的成员函数，该函数接受一个类型为std::ostream&的参数，并且返回类型是void。如果满足那么这个类型T就满足了Printable的约束。

然后看第二部分代码是定义了一个模板函数print，这个函数接受一个const引用类型名为T的参数。Printable T表示这个模板函数的实参类型必须满足先前定义的Printable这个Concept，也就是实参类型必须有一个print函数，接受一个类型为std::ostream&的参数，返回类型为void。

这段代码的核心就是利用Concept来约束模板函数的参数类型，只有满足Printable的约束才能被这个函数使用，也就是说只要行为对上了就行而不用在意这些具体的类型是什么。这也是一种类型擦除。

使用Concept来实现有着所有在编译期完成多态的优化和缺点，但是相比于CRTP的实现来说，Concept提供编译时类型检查，强调类型的接口和约束，使得错误可以在编译时发现。但是从报错信息也来看，Concept是更加清晰的(这也是Concept一大优势)。

## 总结

本文讲述了类型擦除以及不同的实现方式，这就是C++实现一个特性的过程中有着茫茫多的实现方案，在类型擦除的实现这个足足提供了五种方案，给选择困难症来了很大的痛苦，虽然条条大路通罗马，但是你不能保证你绕了多少路啊。得清楚每种方案的优劣才可以最终下判断，这就是C++的折磨之处。五种方案中第一个void\*不提倡使用，但是后面四种都是有在使用的，并且除了虚函数其他三种都可以在编译期完成，性能上是更优的。但是各种实现的使用场景有所不用，如下所示：

*   void_：适用于C风格的API设计和处理一些低级操作，如直接内存操作等等。但在现代C++编程中尽量避免使用void_，因为它并不安全，不能提供类型检查。
*   虚函数：虚函数主要用于实现“运行时多态”，即在运行时选择调用哪个类的哪个函数。适用于需要在运行时改变行为，或者处理由多种不同类型对象组成的集合的场景。并且虚函数的实现十分的简单易懂(效率也不见得差特别多)。
*   std::variant：适合在有限的、确定的类型集合中进行类型擦除。比如作为函数返回值，需要返回不同类型值的场景，或者需要存储有限种类型的容器等。
*   CRTP：适用于在编译时需要确定类型，且需要提供高性能的场景。比如当你需要为多个类型提供相同的接口，但又不想付出虚函数的开销时可以使用，但是需要注意是否类层次结构是否比较复杂，那么使用CRTP会比较繁琐。
*   Concept-based Polymorphism：适用于需要提供强类型检查，且接口适用于多个类型的场景。Concepts提供了更好理解的代码表达形式和编译时的错误检查和信息，适合实现泛型编程和模板库。


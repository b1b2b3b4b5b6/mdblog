<!--
author: lumos
date: 2026-02-02
title:  
tags: 
category: 
status: draft
summary: 
-->


# 类型萃取（Type Traits）
类型萃取用于在编译期判断类型属性、变换类型，核心位于`<type_traits>`。

```cpp
#include <type_traits>
using namespace std;
```

##### 核心概念
- **类型判定**：`is_xxx`系列，判断类型是否满足某种性质
- **类型变换**：`remove_xxx`、`add_xxx`、`decay`等
- **结果形式**：`::value`或`_v`变量模板，`::type`或`_t`别名模板

##### 常用判定类（is_*)
| 方式                              | 说明                                  |
| :-------------------------------- | :----------------------------------- |
| is_same<T, U>                     | 是否同一类型                          |
| is_integral<T>                    | 是否为整型                            |
| is_floating_point<T>              | 是否为浮点型                          |
| is_arithmetic<T>                  | 是否算术类型                          |
| is_enum<T>                        | 是否枚举                              |
| is_class<T>                       | 是否类/结构体                         |
| is_union<T>                       | 是否联合体                            |
| is_pointer<T>                     | 是否指针                              |
| is_reference<T>                   | 是否引用                              |
| is_lvalue_reference<T>            | 是否左值引用                          |
| is_rvalue_reference<T>            | 是否右值引用                          |
| is_const<T>                       | 是否const                             |
| is_volatile<T>                    | 是否volatile                          |
| is_array<T>                       | 是否数组                              |
| is_function<T>                    | 是否函数类型                          |
| is_void<T>                        | 是否void                              |
| is_null_pointer<T>                | 是否nullptr_t                         |
| is_signed<T>                      | 是否有符号类型                        |
| is_unsigned<T>                    | 是否无符号类型                        |
| is_trivial<T>                     | 是否平凡类型                          |
| is_trivially_copyable<T>          | 是否平凡可拷贝                        |
| is_standard_layout<T>             | 是否标准布局                          |
| is_pod<T>                         | 是否POD类型（已弃用）                 |
| is_empty<T>                       | 是否空类                              |
| is_polymorphic<T>                 | 是否多态（有虚函数）                  |
| is_abstract<T>                    | 是否抽象类                            |
| is_final<T>                       | 是否final类                           |
| is_aggregate<T>                   | 是否聚合类型（C++17）                 |
| is_move_constructible<T>          | 是否可移动构造                        |
| is_copy_constructible<T>          | 是否可拷贝构造                        |
| is_default_constructible<T>       | 是否可默认构造                        |
| is_destructible<T>                | 是否可析构                            |
| is_trivially_destructible<T>      | 是否平凡析构                          |
| is_nothrow_move_constructible<T>  | 是否nothrow移动构造                   |
| is_nothrow_copy_constructible<T>  | 是否nothrow拷贝构造                   |
| is_nothrow_destructible<T>        | 是否nothrow析构                       |
| is_assignable<T, U>               | T是否可从U赋值                        |
| is_copy_assignable<T>             | 是否可拷贝赋值                        |
| is_move_assignable<T>             | 是否可移动赋值                        |
| is_swappable<T>                   | 是否可交换（C++17）                   |
| is_invocable<F, Args...>          | 是否可调用                            |
| is_base_of<Base, Derived>         | 是否为基类关系                        |
| is_convertible<From, To>          | 是否可转换                            |

##### 常用变换类（*_t）
| 方式                              | 说明                                  |
| :-------------------------------- | :----------------------------------- |
| remove_const_t<T>                 | 去除const                             |
| remove_reference_t<T>             | 去除引用                              |
| remove_pointer_t<T>               | 去除指针                              |
| remove_cv_t<T>                    | 去除const和volatile                   |
| remove_cvref_t<T>                 | 去除cv和引用（C++20）                 |
| add_const_t<T>                    | 添加const                             |
| add_lvalue_reference_t<T>         | 添加左值引用                          |
| add_rvalue_reference_t<T>         | 添加右值引用                          |
| add_pointer_t<T>                  | 添加指针                              |
| make_signed_t<T>                  | 转为有符号类型                        |
| make_unsigned_t<T>                | 转为无符号类型                        |
| decay_t<T>                        | 退化（去引用/去cv/数组转指针/函数转指针） |
| enable_if_t<cond, T>              | 条件成立时产生T，否则替换失败          |
| conditional_t<cond, T, F>         | 条件选择类型                          |
| common_type_t<T...>               | 推导公共类型                          |
| underlying_type_t<T>              | 枚举的底层类型                        |
| aligned_storage_t<size, align>    | 生成对齐的存储类型                    |

```cpp
// make_signed/unsigned 示例
using S1 = std::make_signed_t<unsigned int>;    // int
using U1 = std::make_unsigned_t<int>;           // unsigned int

// 注意：只能用于整型
// std::make_signed_t<double>;  // 错误！

// remove_cvref（C++20前需要组合）
template <class T>
using remove_cvref_t = std::remove_cv_t<std::remove_reference_t<T>>;
```

##### 函数调用相关萃取
| 方式                              | 说明                                  |
| :-------------------------------- | :----------------------------------- |
| result_of<F(Args...)>             | 推导函数调用返回类型（C++17弃用）      |
| invoke_result_t<F, Args...>       | 推导调用返回类型（C++17+，推荐）       |
| is_invocable<F, Args...>          | 检测是否可调用                        |
| is_invocable_r<R, F, Args...>     | 检测可调用且返回R                     |
| is_nothrow_invocable<F, Args...>  | 检测可调用且不抛异常                  |

```cpp
// result_of 示例（已弃用，用 invoke_result 替代）
int add(int a, int b) { return a + b; }
using R1 = std::result_of<decltype(add)(int, int)>::type;  // int

// invoke_result 现代写法
using R2 = std::invoke_result_t<decltype(add), int, int>;  // int

// Lambda 和函数对象
auto lambda = [](int x) -> double { return x * 1.5; };
using R3 = std::invoke_result_t<decltype(lambda), int>;    // double
```

##### 数组与大小查询
```cpp
// 数组维度
constexpr size_t dim = std::rank_v<int[3][4][5]>;         // 3

// 指定维度的大小
constexpr size_t size0 = std::extent_v<int[3][4], 0>;     // 3
constexpr size_t size1 = std::extent_v<int[3][4], 1>;     // 4
constexpr size_t size2 = std::extent_v<int[3][4], 2>;     // 0（越界）

// 移除数组维度
using T1 = std::remove_extent_t<int[5]>;                  // int
using T2 = std::remove_extent_t<int[3][4]>;               // int[4]
using T3 = std::remove_all_extents_t<int[3][4][5]>;       // int
```

##### 常用值形式
```cpp
static_assert(is_integral<int>::value, "int is integral");
static_assert(is_integral_v<int>, "int is integral");

using U = remove_reference_t<int&>; // U == int
```

##### 逻辑组合（C++17）
```cpp
// 逻辑与：所有条件都为真
template <class... B>
using conjunction = std::conjunction<B...>;

// 逻辑或：至少一个条件为真
template <class... B>
using disjunction = std::disjunction<B...>;

// 逻辑非
template <class B>
using negation = std::negation<B>;

// 示例：检测类型是否为整型或浮点型
template <class T>
constexpr bool is_numeric_v = 
    std::disjunction_v<std::is_integral<T>, std::is_floating_point<T>>;

// 检测类型是否既是整型又是无符号的
template <class T>
constexpr bool is_unsigned_int_v = 
    std::conjunction_v<std::is_integral<T>, std::is_unsigned<T>>;
```

##### declval - 获取类型的"假想"对象
```cpp
// declval 不需要类型是可构造的，常用于表达式推导
template <class T>
decltype(std::declval<T>().foo()) test();

// 示例：检测成员函数
template <class T, class = void>
struct has_size : std::false_type {};

template <class T>
struct has_size<T, std::void_t<decltype(std::declval<T>().size())>>
    : std::true_type {};

// 使用
static_assert(has_size<std::vector<int>>::value);  // true
static_assert(!has_size<int>::value);              // true
```

##### void_t - SFINAE 检测习惯用法（C++17）
```cpp
template <class...>
using void_t = void;

// 检测是否有 value_type 成员
template <class, class = void>
struct has_value_type : std::false_type {};

template <class T>
struct has_value_type<T, std::void_t<typename T::value_type>>
    : std::true_type {};

// 检测是否可以进行 + 运算
template <class T, class U, class = void>
struct is_addable : std::false_type {};

template <class T, class U>
struct is_addable<T, U, 
    std::void_t<decltype(std::declval<T>() + std::declval<U>())>>
    : std::true_type {};
```

##### 内存与对齐相关
```cpp
// 获取类型的对齐要求
constexpr size_t align = std::alignment_of_v<double>;  // 通常是 8

// 创建对齐的存储空间
std::aligned_storage_t<sizeof(MyClass), alignof(MyClass)> storage;
MyClass* ptr = new (&storage) MyClass();  // placement new

// 获取最大对齐
using MaxAligned = std::aligned_union_t<0, int, double, char>;
```

##### SFINAE与enable_if
```cpp
template <class T, class = enable_if_t<is_integral_v<T>>>
T add_one(T v) {
	return v + 1;
}

// 替代：返回类型上启用
template <class T>
enable_if_t<is_floating_point_v<T>, T> half(T v) {
	return v / 2;
}
```

##### if constexpr（C++17）
```cpp
template <class T>
void print_type() {
	if constexpr (is_integral_v<T>) {
		cout << "integral" << endl;
	} else if constexpr (is_floating_point_v<T>) {
		cout << "floating" << endl;
	} else {
		cout << "other" << endl;
	}
}
```

##### 自定义类型萃取
```cpp
// 默认：false
template <class T>
struct is_widget : false_type {};

struct Widget {};
template <>
struct is_widget<Widget> : true_type {};

static_assert(is_widget<Widget>::value);
```

##### 与迭代器相关的萃取
```cpp
template <class Iter>
using iter_value_t = typename iterator_traits<Iter>::value_type;

template <class Iter>
using iter_cat_t = typename iterator_traits<Iter>::iterator_category;

template <class Iter>
using iter_diff_t = typename iterator_traits<Iter>::difference_type;
```

##### 高级应用示例

**1. 类型完美转发的返回类型推导**
```cpp
template <class F, class... Args>
auto invoke_wrapper(F&& f, Args&&... args)
    -> std::invoke_result_t<F, Args...>
{
    return std::invoke(std::forward<F>(f), std::forward<Args>(args)...);
}
```

**2. 根据类型特性选择不同实现**
```cpp
// 根据是否平凡可拷贝选择实现
template <class T>
void copy_impl(T* dest, const T* src, size_t n, std::true_type) {
    // 平凡类型：使用 memcpy
    std::memcpy(dest, src, n * sizeof(T));
}

template <class T>
void copy_impl(T* dest, const T* src, size_t n, std::false_type) {
    // 非平凡类型：逐个调用拷贝构造
    for (size_t i = 0; i < n; ++i)
        new (&dest[i]) T(src[i]);
}

template <class T>
void copy_elements(T* dest, const T* src, size_t n) {
    copy_impl(dest, src, n, std::is_trivially_copyable<T>{});
}
```

**3. 概念模拟（Concepts）- C++17 风格**
```cpp
// 要求类型可复制且可移动
template <class T>
using Copyable = std::conjunction<
    std::is_copy_constructible<T>,
    std::is_copy_assignable<T>
>;

template <class T>
using Movable = std::conjunction<
    std::is_move_constructible<T>,
    std::is_move_assignable<T>
>;

template <class T, class = std::enable_if_t<Copyable<T>::value>>
void process(const T& obj) {
    T copy = obj;  // 安全
}
```

**4. 编译期类型选择**
```cpp
// 根据大小选择存储类型
template <size_t N>
using FastInt = std::conditional_t<(N <= 8),  uint8_t,
                std::conditional_t<(N <= 16), uint16_t,
                std::conditional_t<(N <= 32), uint32_t, uint64_t>>>;

FastInt<10> x;   // uint16_t
FastInt<40> y;   // uint64_t
```

**5. 检测特定成员函数**
```cpp
// 检测是否有 begin() 和 end()
template <class T, class = void>
struct is_iterable : std::false_type {};

template <class T>
struct is_iterable<T, std::void_t<
    decltype(std::begin(std::declval<T>())),
    decltype(std::end(std::declval<T>()))
>> : std::true_type {};

template <class T>
constexpr bool is_iterable_v = is_iterable<T>::value;
```

##### 常见陷阱
- `is_pointer<T&>`为false，先`remove_reference_t`
- `const T`与`T const`等价，`remove_const_t`只去最外层const
- `decay_t`会把数组/函数退化为指针，注意保留类型时不要用decay
- `result_of`已在C++17弃用、C++20移除，使用`invoke_result`替代
- `declval<T>()`只能用于不求值上下文（decltype、sizeof等）
- `void_t`模式要注意模板特化的顺序，通用版本要在前
- `conjunction`和`disjunction`具有短路特性

##### C++20 Concepts 对比
```cpp
// C++17 类型萃取方式
template <class T, class = std::enable_if_t<
    std::is_integral_v<T> && std::is_unsigned_v<T>>>
void foo(T value);

// C++20 Concepts 方式（更简洁）
template <std::integral T>
    requires std::unsigned_integral<T>
void foo(T value);
```

##### 性能考虑
- 类型萃取都是**编译期计算**，运行时零开销
- `is_trivially_*`系列可指导编译器优化（如使用memcpy）
- 过度使用SFINAE可能增加编译时间

##### 小结
- **判定**：`is_xxx`系列检查类型属性
- **变换**：`remove/add/decay/conditional/enable_if`修改类型
- **推导**：`invoke_result/declval/common_type`推导新类型
- **组合**：`conjunction/disjunction/negation`逻辑组合
- **检测**：`void_t + declval`检测成员/操作是否存在
- C++17建议使用`_v`与`_t`简化写法
- C++20后可优先考虑使用Concepts替代部分场景

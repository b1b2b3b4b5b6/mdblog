<!--
author: lumos
date: 2026-02-02
title:  
tags: 
category: 
status: draft
summary: 
-->


# C++ 内存序（Memory Order）

内存序用于控制原子操作的同步和可见性行为，位于 `<atomic>` 头文件。

```cpp
#include <atomic>
```

![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202307251830986.png)

## 六种内存序

### memory_order_relaxed
- **同步保证**：无
- **重排限制**：无（仅保证原子性）
- **适用场景**：计数器等不需要同步的场景
- **特点**：
  - 只保证操作的**原子性**
  - 不建立 happens-before 关系
  - 性能最优，但无法用于线程间同步

```cpp
std::atomic<int> counter{0};
// 多线程递增，只关心最终值
counter.fetch_add(1, std::memory_order_relaxed);
```

### memory_order_acquire（用于读操作）
- **同步保证**：与配对的 release 建立同步
- **重排限制**：acquire **之后**的读写不能重排到 acquire **之前**
- **可见性**：配对的 release 写入及之前的所有操作对当前线程可见
- **适用场景**：读取共享数据前建立同步点

```cpp
std::atomic<bool> ready{false};
int data = 0;

// 线程2
while (!ready.load(std::memory_order_acquire));  // 等待
// 此时能看到 data = 42
```

### memory_order_release（用于写操作）
- **同步保证**：与后续的 acquire 建立同步
- **重排限制**：release **之前**的读写不能重排到 release **之后**
- **可见性**：release 及之前的所有写操作对后续 acquire 可见
- **适用场景**：发布数据前建立同步点

```cpp
// 线程1
data = 42;
ready.store(true, std::memory_order_release);  // 发布
```

### memory_order_acq_rel（用于 RMW 操作）
- **同步保证**：同时具备 acquire + release 语义
- **重排限制**：
  - 之前的操作不能重排到之后
  - 之后的操作不能重排到之前
- **适用场景**：read-modify-write 操作（如 `fetch_add`、`exchange`）

```cpp
std::atomic<int> x{0};
int old = x.fetch_add(1, std::memory_order_acq_rel);
```

### memory_order_seq_cst（默认，顺序一致）
- **同步保证**：最强，建立全局一致顺序
- **重排限制**：最严格
- **可见性**：多个原子变量的所有 seq_cst 操作在所有线程中观察到相同顺序
- **适用场景**：默认选择，简单直观但性能开销最大

```cpp
std::atomic<int> x{0}, y{0};
// 所有线程看到的 x、y 修改顺序一致
x.store(1, std::memory_order_seq_cst);
y.store(1, std::memory_order_seq_cst);
```

## 核心概念

### happens-before 关系
- release 操作 happens-before 配对的 acquire 操作
- acquire 之后的操作能看到 release 之前的所有写入

### 同步点（Synchronization Point）
- acquire/release 配对建立同步点
- 同步点之间建立内存可见性保证

### 重排序（Reordering）
- **编译器重排**：优化时调整指令顺序
- **CPU 重排**：乱序执行、写缓冲等
- 内存序通过内存屏障（fence）限制重排

## 使用建议

| 内存序          | 性能 | 复杂度 | 使用场景                     |
| :-------------- | :--- | :----- | :--------------------------- |
| relaxed         | 最快 | 低     | 计数器、统计                 |
| acquire/release | 中等 | 中等   | 生产者-消费者、锁            |
| seq_cst         | 最慢 | 低     | 默认选择、复杂同步           |

## 典型模式

### 自旋锁
```cpp
class SpinLock {
    std::atomic<bool> flag{false};
public:
    void lock() {
        while (flag.exchange(true, std::memory_order_acquire));
    }
    void unlock() {
        flag.store(false, std::memory_order_release);
    }
};
```

### 双检锁单例
```cpp
std::atomic<Singleton*> instance{nullptr};
std::mutex mtx;

Singleton* get_instance() {
    auto* p = instance.load(std::memory_order_acquire);
    if (!p) {
        std::lock_guard lock(mtx);
        p = instance.load(std::memory_order_relaxed);
        if (!p) {
            p = new Singleton();
            instance.store(p, std::memory_order_release);
        }
    }
    return p;
}
```

## 常见误区

1. **relaxed ≠ 无原子性**：relaxed 保证原子性，只是无同步
2. **acquire/release 需配对**：单独使用无意义
3. **seq_cst ≠ 串行执行**：不同原子变量的操作仍可并行
4. **不是万能锁**：内存序不能代替互斥锁保护临界区

## 调试建议

- 默认使用 `seq_cst`，确认正确后再优化
- 使用 ThreadSanitizer 检测数据竞争
- 性能瓶颈时才考虑 relaxed/acquire/release

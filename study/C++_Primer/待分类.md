# 待分类
string sso优化后，move会拷贝数据并清空原有数据
new会触发构造析构，返回正确类型，失败抛出异常，大小自动计算，可以重载，支持申请数组
覆盖是虚函数的特性，隐藏是派生类同名不同参方法导致的
condition_variable 需要 unique_lock 而不是 lock_guard，是因为：
* 条件变量的 wait() 会释放锁并等待，被唤醒后重新加锁
* 这需要锁能够unlock/lock操作
* lock_guard 只能在析构时解锁，不支持手动unlock
* unique_lock 支持手动lock/unlock操作
* std::localtime线程不安全，因为内部有静态缓冲区




### 使用 `std::format` (C++20)
```cpp
#include <format>

std::string format_log(const std::string& message) {
    auto now = std::chrono::system_clock::now();
    return std::format("{:%Y-%m-%d %H:%M:%S} {}\n", now, message);
    // 更快、更安全、更简洁
}
```

### Trade-off 权衡

你说的"log不及时"是对的，但不全面：

| 优化 | 好处 | 代价 | 权衡方案 |
|------|------|------|----------|
| **异步写入** | 不阻塞业务 | 日志延迟、可能丢失 | 提供sync()接口，关键日志立即写 |
| **批量flush** | 减少IO | 进程崩溃丢日志 | 定时flush（如100ms） + 注册信号处理 |
| **队列有界** | 防止内存爆炸 | 队列满时丢日志 | 监控队列长度，告警 |
| **循环缓冲** | 内存固定 | 旧日志被覆盖 | 分级别，ERROR立即写 |


### 生产环境最佳实践

1. **分级别**：DEBUG/INFO/WARN/ERROR/FATAL
2. **异步写入**：不阻塞业务线程
3. **线程安全**：多线程并发写入
4. **日志轮转**：按大小或时间切分文件
5. **格式化**：时间戳、线程ID、级别、文件行号
6. **性能监控**：队列长度、丢失计数
7. **优雅关闭**：进程退出前刷新所有日志
8. **信号处理**：捕获SIGTERM等，安全退出

#### 推荐架构：

```
业务线程1 ───┐
业务线程2 ───┼──→ 无锁队列 ──→ 后台线程 ──→ 批量写入 ──→ 磁盘
业务线程3 ───┘     (lockfree)    (1个)       (buffered)
```

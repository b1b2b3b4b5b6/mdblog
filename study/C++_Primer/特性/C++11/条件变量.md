# 条件变量

## 概要
条件变量（`std::condition_variable` / `std::condition_variable_any`）用于线程之间基于条件的等待与通知，配合互斥量（`std::mutex` / `std::unique_lock`）实现高效的等待/唤醒机制。

## 为什么需要条件变量
- 当线程需要等待某个状态变为真（例如缓冲区非空/非满）时，条件变量提供了比轮询更高效的等待方式。
- 支持超时等待与谓词检查，能减少竞态和 CPU 空转。

## 核心概念

### 基本API
- `wait(std::unique_lock<std::mutex>& lock)`：阻塞等待，返回前会自动释放互斥锁，返回后重新加锁。建议使用带谓词的重载以处理伪唤醒。
- `wait_for` / `wait_until`：带超时的等待，返回 `std::cv_status::timeout` 或 `std::cv_status::no_timeout`，或使用谓词重载直接返回 `bool`。
- `notify_one()`：唤醒一个等待线程。
- `notify_all()`：唤醒所有等待线程。

### `std::condition_variable` vs `std::condition_variable_any`
- `std::condition_variable` 仅与 `std::unique_lock<std::mutex>` 配合。
- `std::condition_variable_any` 可与任意满足 Lock 概念的类型配合（接口更通用，代价通常更高）。

## 使用要点
- 永远在循环中或使用谓词重载检查条件（处理`伪唤醒`）：
  - `cond.wait(lock, []{ return ready; });`
- 等待前应持有互斥锁；`wait` 会在阻塞时释放锁，返回时重新获取。
- 通知可在持锁或释放锁后进行；为降低竞争，常在修改共享状态后释放锁再通知。

### 伪唤醒
指的是等待在 std::condition_variable 等同步原语上的线程在没有收到任何显式通知（notify_one/notify_all）且等待超时未发生的情况下被唤醒——也就是说 wait 或 wait_for 返回了，但等待的条件并未必为真。C++ 标准允许这种情况，`使用者不能假定唤醒必然对应有效条件`。

**常见原因**
- 平台/实现细节：底层操作系统或同步原语可能因为中断、内核实现优化或其它内部事件产生虚假唤醒。
- 信号/异步事件：系统信号或线程调度导致唤醒。
- 实现上的合并/广播/不同锁实现产生的噪声唤醒

## 典型示例：生产者-消费者
```cpp
#include <condition_variable>
#include <mutex>
#include <queue>
#include <thread>
#include <optional>

std::queue<int> q;
std::mutex m;
std::condition_variable cv;
bool finished = false;

void producer() {

    std::lock_guard<std::mutex> lk(m);
    finished = true;
    cv.notify_all();
}

void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lk(m);
        cv.wait(lk, [] { return !q.empty() || finished; }); // 谓词处理伪唤醒
        if (!q.empty()) {
            int v = q.front(); q.pop();
            lk.unlock(); // 尽早释放锁以缩短临界区
            // 处理 v
        } else if (finished) {
            break;
        }
    }
}
```

## 超时等待示例
```cpp
std::unique_lock<std::mutex> lk(m);
if (cv.wait_for(lk, std::chrono::milliseconds(100), []{ return ready; })) {
    // ready 为真
} else {
    // 超时处理
}
```

# 异步操作
## 为什么需要异步操作
当需要多线程处理任务, 并获取结果时, 通常的做法是使用`std::thread`起线程, 然后`thread.join()`等待结束并获取结果, 这种操作比较繁琐

`异步操作`提供了以下的便利:
- 自动创建线程执行函数, 得到类似`句柄`的东西
- 当需要结果时直接从`句柄`中获取即可, 如果执行未结束, 则等待

## C++11的异步操作
C++11提供了一些异步机制和接口:
### std::future
提供`访问异步操作结果状态的机制`, 用法如下
```C++
//查询future的状态
std::future_status status;
do {
    status = future.wait_for(std::chrono::seconds(1));
    if (status == std::future_status::deferred) {
        std::cout << "deferred\n";
    } else if (status == std::future_status::timeout) {
        std::cout << "timeout\n";
    } else if (status == std::future_status::ready) {
        std::cout << "ready!\n";
} while (status != std::future_status::ready);
```

`获取结果`有三种方式
- `get` 等待异步操作结束并返回结果
- `wait` 只是等待异步操作完成，没有返回值
- `wait_for` 超时等待返回结果

`future_status`有三种状态
- `deferred` 异步操作还没开始
- `ready` 异步操作已经完成
- `timeout` 异步操作超时

注:
- 普通future只能`get`一次, 因为`get`操作会移动内部的值, 导致future`无效`
- 无法主动给future设置值, 需要配置promise来set_value
- future内部是用`条件变量+互斥锁`完成的

#### shared_future
如果要多次获取值, 需要使用`std::shared_future`, 通过普通的future的`share()`方法获取即可, 如下

```C++
std::future_status status;
auto f_shared = f1.share();

std::future<int> f2 = std::async(std::launch::async, [f_shared]()
                                { return f_shared.get() + 1; });
std::future<int> f3 = std::async(std::launch::async, [f_shared]()
                                { return f_shared.get() + 2; });

```

### std::promise
为`获取线程函数中的值`提供便利, 用法如下
```C++
std::promise<int> prom;
auto func = [](std::promise<int> &prom)
{
    promise.set_value_at_thread_exit(42);//线程结束推出时才会设置值
    prom.set_value(99);
};
std::thread t(func, std::ref(prom)); //在子线程中修改prom的值
std::future<int> f = prom.get_future();
std::cout << f.get() << std::endl;
```
流程如下
- 设值
    - 通过`set_value`设值(只能设一次),
    - 通过`set_value_at_thread_exit`预先设置值, 线程结束退出时才会赋值
- 通过`get_future()`获取future, 然后`future.get()`获取值

注:
>promise实际使用future来实现值的`按需使用`
>`get`何时返回取决与何时`set_value`, 与promise所在`线程是否结束`无关


### std::packaged_task
`包装了std::function`, 以便异步调用, 用法如下
```C++
auto func = [](int a, int b)
{ return a + b; };
std::packaged_task<int(int, int)> task(func);
auto f = task.get_future();

std::thread t(std::move(task), 1, 2);
std::cout << f.get() << std::endl;
```
流程如下
1. 函数对象中返回值
1. 通过`get_future()`获取future, 然后`future.get()`获取值
注:
>和promise类似, 但是值是在函数对象执行完成后`set_value`的

### std::async
如果上面的的`std::packaged_task`实现异步操作, 还是显得麻烦, 因为要获取`future`再拿到值
`std::async`更加简单, 直接返回`future`, 通过`get`取值即可, 如下
```C++
auto f = std::async(
    std::launch::async, [](int a, int b)
    { return a + b; },
    1, 2);
std::cout << f.get() << std::endl; // 3
```

其中`std::launch::async`是线程的创建策略, 列举如下
- `std::launch::async` 在调用async时就创建线程
- `std::launch::deferred` 延迟加载方式创建线程, 这种情况下, 只有到了调用future的`get`或`wait`时才创建线程

#### 返回值析构顺序
`std::async`返回的future在`析构时会等待新建线程结束`,
所以如果没有变量装std::async的返回值时, std::async将会阻塞主线程执行, 如下
```C++
    std::cout << "Before async call in Awaiter::await_suspend" << std::endl;
    std::async([=](){
        std::this_thread::sleep_for(1s);});
    //这里实际在sleep后执行
    std::cout << "After async call in Awaiter::await_suspend" << std::endl;
```
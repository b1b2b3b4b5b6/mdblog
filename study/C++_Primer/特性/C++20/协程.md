# C++ 协程（Coroutine）
示例代码
```C++
#include <iostream>
#include <coroutine>

template <bool READY>
struct Awaiter
{
    bool await_ready() noexcept
    {
        std::cout << "await_ready: " << READY << std::endl;
        return READY;
    }
    void await_resume() noexcept
    {
        std::cout << "await_resume" << std::endl;
    }
    void await_suspend(std::coroutine_handle<>) noexcept
    {
        std::cout << "await_suspend" << std::endl;
    }
};

struct TaskPromise
{
    struct promise_type
    {
        promise_type()
        {
            std::cout << "promise_type constructed" << std::endl;
        }
        ~promise_type()
        {
            std::cout << "promise_type destructed" << std::endl;
        }
        TaskPromise get_return_object()
        {
            std::cout << "get_return_object" << std::endl;
            return TaskPromise{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        Awaiter<true> initial_suspend() noexcept
        {
            std::cout << "initial_suspend" << std::endl;
            return {};
        }
        Awaiter<true> final_suspend() noexcept
        {
            std::cout << "final_suspend" << std::endl;
            return {};
        }
        void unhandled_exception()
        {
            std::cout << "unhandled_exception" << std::endl;
        }
        void return_void() noexcept
        {
            std::cout << "return_void" << std::endl;
        }
    };

    void resume()
    {
        std::cout << "start exec handle.resume" << std::endl;
        handle.resume();
    }
    std::coroutine_handle<promise_type> handle;
};

TaskPromise task_func()
{
    std::cout << "task first run" << std::endl;
    co_await Awaiter<false>{};
    std::cout << "task resume" << std::endl;
}

int main()
{
    auto promise = task_func();
    promise.resume();

    return 0;
}
```

执行输出如下
```txt
promise_type constructed
get_return_object
initial_suspend
await_ready: 1
await_resume
task first run
await_ready: 0
await_suspend
start exec handle.resume
await_resume
task resume
return_void
final_suspend
await_ready: 1
await_resume
promise_type destructed
```

## 流程图
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202511111859961.png)


![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202511111900469.png)
### 协程状态伪代码
```C++
template <> struct coroutine_handle<noop_coroutine_promise> {
  struct __frame {
    static void __dummy_resume_destroy() {}

    void (*__r)() = __dummy_resume_destroy; // 协程句柄 resume 函数地址
    void (*__d)() = __dummy_resume_destroy; // 协程句柄 destroy 函数地址
    struct noop_coroutine_promise __p;
  };
  static __frame _S_fr;
  void *_M_fr_ptr = &_S_fr;
};
```

### 协程执行伪代码
```C++
T some_coroutine(P param)
{
  // 为协程帧分配内存，如果 promsie 存在内存分配重载则利用 promise 的内存分配函数
  auto* f = new coroutine_frame(std::forward<P>(param));

  // 返回协程函数关联的面向用户的对象，在 Coro.hpp 中即 task，
  // returnObject 会在协程第一次陷入 suspend 状态后通过语句`return returnObject`被返回，
  auto returnObject = f->promise.get_return_object();

  // 控制协程创建时的调度逻辑
  co_await promise.initial_suspend();
  try
  {
    // 用户在协程函数体内定义的逻辑
    <body-statements>
  }
  catch (...)
  {
    // 处理协程运行中抛出的异常
    promise.unhandled_exception();
  }
FinalSuspend:
  // 控制协程结束时的调度逻辑
  co_await promise.final_suspend();
}
```

### co_return和co_yield伪代码
```C++
// 用户侧            编译器侧
co_return value <==> promise.return_value(value);
co_return       <==> promise.return_void(value);
co_yield  value <==> co_await promise.yield_value(value); // 注意 co_yield 会产生调度点
```

### 编译器获取awaiter的伪代码
```C++
template<typename P, typename T>
decltype(auto) get_awaitable(P& promise, T&& expr)
{
  if constexpr (has_any_await_transform_member_v<P>)
    return promise.await_transform(static_cast<T&&>(expr));
  else
    return static_cast<T&&>(expr);
}

template<typename Awaitable>
decltype(auto) get_awaiter(Awaitable&& awaitable)
{
  if constexpr (has_member_operator_co_await_v<Awaitable>)
    return static_cast<Awaitable&&>(awaitable).operator co_await();
  else if constexpr (has_non_member_operator_co_await_v<Awaitable&&>)
    return operator co_await(static_cast<Awaitable&&>(awaitable));
  else
    return static_cast<Awaitable&&>(awaitable);
}
```

### co_await伪代码
```C++
{
  auto&& value = <expr>;

  auto&& awaitable = get_awaitable(promise, static_cast<decltype(value)>(value));
  auto&& awaiter = get_awaiter(static_cast<decltype(awaitable)>(awaitable));

  // 如果 await_ready 返回 true 就不需要执行下面的逻辑从而提高效率
  if (!awaiter.await_ready())
  {
    using handle_t = std::coroutine_handle<P>;

    using await_suspend_result_t =
      decltype(awaiter.await_suspend(handle_t::from_promise(promise)));

    // 在该处协程陷入 suspend 状态，编译器生成代码来保存协程当前的运行状态
    <suspend-coroutine>

    if constexpr (std::is_void_v<await_suspend_result_t>)
    {
      awaiter.await_suspend(handle_t::from_promise(promise));
      <return-to-caller-or-resumer>
    }
    else
    {
      // 这里暂不考虑返回 std::coroutine_handle 的 await_suspend
      static_assert(
         std::is_same_v<await_suspend_result_t, bool>,
         "await_suspend() must return 'void' or 'bool'.");

      if (awaiter.await_suspend(handle_t::from_promise(promise)))
      {
        <return-to-caller-or-resumer>
      }
    }
    // 协程陷入 suspend 状态后恢复会从该处开始执行而不是从<suspend-coroutine>处
    <resume-point>
  }

  return awaiter.await_resume();
}
```
可以看出, 协程的`上下文切换`是在awaiter中实现的, 上下文切换中需要长期保存的变量也就放在awaiter数据中(awaiter本身就在协程堆帧内), 所以可以跨线程使用
注
>上述代码未考虑返回 std::coroutine_handle 的 await_suspend



## 概念
### `协程`
指其`返回值类型`能够实例化模板类型`_Coroutine_traits`的函数, 如下

```C++
template <class _Ret, class = void>
struct _Coroutine_traits {};

template <class _Ret>
struct _Coroutine_traits<_Ret, void_t<typename _Ret::promise_type>> {
    using promise_type = typename _Ret::promise_type;
};

template <class _Ret, class...>
struct coroutine_traits : _Coroutine_traits<_Ret> {};

```

### `承诺对象`
如上述中的`_Ret::promise_type`, 表现形式必须是`返回值类型::promise_type`, 需要实现以下接口:
- `auto get_return_object()` 用于生成协程函数的返回对象
- `auto initial_suspend()` 协程开始执行时，用co_await调用其返回值
- `void return_value(T v)` 调用co_return v后会调用
- `auto yield_value(T v)` 调用co_yield后会调用
- `auto final_suspend() noexcept` 在协程代码执行完退出时, 用co_await调用其返回值
注:
>以上所有调用都是编译器安排的, 用户无法直接控制
>如果打算用自定义内存分配器为协程帧分配内存，那么只需要为 promise 定义operator new和operator delete即可


### `协程返回值对象` 
并不是用户显示实例化, 是`编译器构建`返回给调用方的(只在第一次返回)
- 实际返回值对象的构建是通过`promise_type`的`get_return_object`完成的
- 返回值对象在`协程的状态`创建出来后立即调用调用`get_return_object`创建

### `协程状态`
协程在开始执行第一步就会使用`operator new`开辟内存存放内部执行需要的数据, 这块内存或者这个对象称为`协程状态(coroutine state)`, 会存入以下东西:
- 挂起时的位置,
- 部分局部变量(为什么后面讲解)
- 协程入参(复制构造或移动构造)
- 承诺对象

### `协程句柄`
协程句柄变量定义如下
```C++
template <typename _Promise>
struct coroutine_handle
{
    // [coroutine.handle.con], construct/reset

    constexpr coroutine_handle() noexcept {}

    constexpr coroutine_handle(nullptr_t) noexcept {}

    static coroutine_handle
    from_promise(_Promise &__p)
    {
        coroutine_handle __self;
        __self._M_fr_ptr = __builtin_coro_promise((char *)&__p, __alignof(_Promise), true);
        return __self;
    }

    coroutine_handle &operator=(nullptr_t) noexcept
    {
        _M_fr_ptr = nullptr;
        return *this;
    }

    // [coroutine.handle.export.import], export/import

    constexpr void *address() const noexcept { return _M_fr_ptr; }

    constexpr static coroutine_handle from_address(void *__a) noexcept
    {
        coroutine_handle __self;
        __self._M_fr_ptr = __a;
        return __self;
    }

    // [coroutine.handle.conv], conversion
    constexpr operator coroutine_handle<>() const noexcept
    {
        return coroutine_handle<>::from_address(address());
    }

    // [coroutine.handle.observers], observers
    constexpr explicit operator bool() const noexcept
    {
        return bool(_M_fr_ptr);
    }

    bool done() const noexcept { return __builtin_coro_done(_M_fr_ptr); }

    // [coroutine.handle.resumption], resumption
    void operator()() const { resume(); }

    void resume() const { __builtin_coro_resume(_M_fr_ptr); }

    void destroy() const { __builtin_coro_destroy(_M_fr_ptr); }

    // [coroutine.handle.promise], promise access
    _Promise &promise() const
    {
        void *__t = __builtin_coro_promise(_M_fr_ptr, __alignof(_Promise), false);
        return *static_cast<_Promise *>(__t);
    }

private:
    void *_M_fr_ptr = nullptr;
};

```
协程句柄类型只有一个成员变量`void *_M_fr_ptr`, 就是`协程状态`内存地址, 决定了`协程句柄变量`的性质
其他所有协程操作函数和转换函数, 都依赖`_M_fr_ptr`, 且通过编译器内部指令完成, 如下
- `resume()` 可以恢复协程
- `done()` 可以判断协程是否已经完成
- `destory()` 用户自行销毁协程状态
- `from_promise()` 返回`协程句柄变量`值, 其成员`_M_fr_ptr`值由`promise`对象转换得到
- `promise()` 通过`_M_fr_ptr`转换得到`promise`对象
- `address()` 返回`_M_fr_ptr`
- `from_address` 返回`协程句柄变量`值, 其`_M_fr_ptr`复制为入参值


**协程装填和promise的相互转化**
从`from_promise()`和`promise()`看出, 协程状态和`promise`对象可以相互转换, 原因如下
`promise`对象内存地址 = `协程堆帧/协程状态`地址 + 2个函数指针字节

### `等待体`
比如上述代码中的Awaiter, 是实现了以下接口的struct
- `bool await_ready()` 是否准备好运行了
    - 返回false, 调用await_suspend
    - 返回true, 调用await_resume
- `auto await_suspend(std::coroutine_handle<> handle)` 如果要挂起，调用的接口。其中handle参数就是`co_await`所在的协程函数的协程句柄，其返回值如下
    - void或true 立即挂起
    - false 不挂起`协程句柄`，立即恢复对应协程的运行.
- `auto await_resume()` 协程挂起后恢复时调用, 返回值作为co_wait 操作的返回值。
注:
>可以在`协程返回值类型`中, 也加上`等待体的接口`, 这样就可以直接`await 协程函数`

 
## 协程调用流程

### 调用处理
- C++协程实现为`无栈`协程, `上下文`存储在用户定义数据结构内, 协程`挂起和恢复`不涉及进程调度
- 协程对外体现是一个`协程函数`, `挂起`和`恢复`行为也只针对这个协程函数, 后续简称为`协程`
    - `挂起`指的是`调用协程`后, 中途返回`协程调用方`, 而此时协程内代码并未执行完
        - `调用协程`不仅指的是第一次调用, 后续的`恢复`操作也是
        - `中途返回`的行为是协程内部由`co_await`触发的， ,
    - `恢复`指的是调用`协程句柄的resume()`恢复协程的上下文, 再次`同线程`执行协程内代码, **本质是一次对协程函数的调用**
        - 执行的代码入口就是`co_await的下一行`
        - `恢复`行为可以在任何线程进行, 需要用户注意资源多线程安全

#### 栈溢出问题
如果有这样的代码: 协程函数A内循环调用协程函数B, 协程函数B中会resume协程函数A, 会导致**栈不断增大直至溢出**
问题原因是: B resume A本质是一次函数调用, 结合外层循环形成了`递归调用`,
更进一步说, `主动转移执行权至某个协程`, 会导致`递归调用`
但是可以通过`编译器进行对称转换优化`来解决问题

##### 对称转换优化

![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202511171614664.png)
- `非对称转换` 协程A resume 协程B时, 做了函数调用
- `对称转换` 协程A resume 协程B时, 先pop自身栈帧, 然后做函数调用, 也叫`尾部调用`

**尾部调用**
当前函数栈帧会在实际发起子函数调用时被弹出，子函数返回时会直接返回到当前函数的调用方, 前提如下

- 调用方与被调用方遵循相同的调用规则，并且调用规则支持尾调用
- 调用方与被调用方返回类型相同
- 在返回到调用方之前，不需要在调用之后运行重要的析构函数
- 调用不出在 try/catch 块中

**编译器对称优化前提**
- 至少开启 -O2 编译优化
- `await_suspend`返回

**编译器对称优化原理**
对协程句柄调用`resume`会被编译器优化为`弹出当前栈帧`并用`jmp`指令代替`call`指令来恢复协程

**编译器对称优化缺点**
`await_suspend`返回的协程句柄带有很大不确定性, 不利于编译器做分支预测等优化

### 堆栈处理
编译器将协程运行所需要的全部状态划分为两个部分，分别用栈内存和堆内存存储，我们用协程栈帧和协程堆帧代指：
- `协程堆帧` 协程关联的 promise 以及跨越调度点的局部变量等生命周期较长的对象需要存放在堆帧中, 也就是`协程状态`
- `协程栈帧` 对于未跨越调度点的局部变量以及与普通函数调用相同的过程采用栈帧存储

![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202511151011476.png)

上图可以看出
- 协程函数调用 协程/普通 函数, 流程与[堆栈.md](../../进阶/编译和运行/堆栈.md)一致
- 协程函数内, , 某个寄存器中保存了`协程堆帧`的地址， 比如rbx
    - rbx的规定是`被调函数必须在返回前恢复原值`, 所以协程调用子函数返回时, 仍能获取到`协程堆帧`

有以下效果:
- 协程内不需要跨越调度点的局部变量放在`协程栈帧`中
- 协程内需要跨越调度点的局部变量放在`协程堆帧`中, 比如协程体中co_await的对象

注:
>对于`协程堆帧`大小，编译器会自动计算出一个最合理的值来满足协程对堆内存的需求



## 生命周期
### 协程状态
- 在协程最开始时创建在heap中
- co_await调用`final_suspend`内, 视`await_ready`返回值
    - `true` 销毁协程状, 后续流程与等待体接口流程一致
    - `false` 不销毁协程状态, 需要用户自行调用`协程句柄`的`destory()`接口销毁
### 承诺对象
- 紧接着`协程状态`创建后创建, 保存在`协程状态`中
- 后续随着协程状态销毁而销毁

### 协程返回值
在`get_return_object`创建在stack中, 值返回给协程调用方, 调用方自己按需处理返回值

### 局部变量
看起来和普通函数中的局部变量生命周期一样, 实际变量存在位置要看是否跨越调度点
   

## 协程与线程安全
协程通常会搭配线程池使用，例如下面一段伪代码：
```C++
func() 
{
  // codes part A
  co_await thread_pool.schedule(); // part B 部分交由线程池分配的另一个线程执行
  // codes part B
}
```
上述伪代码将当前协程的执行转移到另一个线程，转移逻辑通常会在await_suspend函数中实现，具体可以实现为将协程句柄投放到别的线程。
但是需要注意，当await_suspend函数将协程句柄交由别的线程执行时可能会出现await_suspend函数还未返回，另一个线程已经把协程执行完毕并且销毁了协程句柄以及 promsie 对象，此时**await_suspend函数内只有访问局部变量是安全的**，因此读者应该对这种跨线程转移协程执行的逻辑保证其线程安全性。

## 其他关键字
### std::suspend_always
std提供的等待体类型, 永远挂起, 内部`await_ready`总是返回false

### std::suspend_never
std提供的等待体类型, 永不挂起, 内部`await_ready`总是返回true
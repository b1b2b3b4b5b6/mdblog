# 基础
- 一个符号到底是一元运算符还是二元运算符由它的上下文决定
- 优先级规定了对象的组合方式，但是没有说明对象按照什么顺序求值

## 左右值
- 左值：用的是对象的身份（内存中的位置）
- 右值：用的是对象的值（内容,一般为临时值）

## 赋值运算符
- 赋值运算的结果是他的左侧运算对象，并且是一个左值，结果的类型是左侧对象的类型
- 如果左右两个运算对象类型不同，则右侧转换成左侧的类型
- 如果左侧对象是内置类型，则初始值列表最多只能包含一个值
- 对于类类型来说，运算的细节由类本身决定
- 初始值列表可以为空

## ++和--操作符
- 前置版本得到递增之后的值
- 后置版本得到递增之前的值

## sizeof
- 对解引用指针执行sizeof得到指针所指向的对象所占空间的大小，指针不需有效
- sizeof运算不会把数组转换成指针来处理
- 对string或vector执行sizeof只返回该类型固定部分的大小

## 逗号运算符
- 首先对左侧求值，然后丢弃
- 结果为右侧表达式的值

## 求值顺序
- 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值
- 只有`&& || ?: ,`按规定先求左侧值

## 隐式转换
* 数组转换成指针
* 指针的转换
    * 整数值0或字面值nullptr转换成任意指针类型
    * 任意指向非常量的指针转换成void*
    * 任意指针转换成const void*
    * ...
* 从算数类型或指针类型到布尔类型的转换
* 转换成常量,如`int i; const int &j = i`
* 用户定义的转换
    * 类型转换操作符
    * 类型转换构造函数

## 强制转换

```cpp
cast-name<type>(expression)
```
>`type` 转换的目标类型
>`expression` 转换的值
>`cast-name` 知道了执行的是那种转换

### static_cast
只要不包含底层const, 都可以使用

### const_cast
只能改变运算对象的底层const
```cpp
const char *pc;
char *p = const_cast<char*>(pc);//正确,但是未定义行为
```
对于将常量对象转换为非常量对象的行为, 称其为`去掉const性质`

### dynamic_cast
* 向上转换时, 与`static_cast`无异
* 可以向下转换(父类到子类), 但是需要父类具有多态(必须含有虚函数)
> 向下转换要求多态的原因是, 需要虚函数表指针来判断实际类型

### reinterpret_cast
为运算对象的位模式提供较低层次上的重新解释, 相当于C的指针强转
```cpp
int *ip;
char *pc = reinterpret_cast<char *>(ip);
```

# 基础

```cpp
class Base final //Base不能被继承
{
public:
	virtual int Value() = 0; //纯虚函数
};


class BaseTwo
{
public:
	virtual int Cost(); //虚函数
	virtual int value() override; //派生类必须要覆盖的虚函数
};


class Foo :
    public Base, private BaseTwo //类派生列表,public是派生类访问说明符
{
};
```
## 继承
通过**继承**联系在一起的类构成一种层次关系，层次关系的根部是**基类**，其他继承得到的类为**派生类**

* 派生类的声明不能包含派生列表

```cpp
class Foo :public Base,BaseTwo; //错误
class Foo ;//正确
```
* 基类必须已经定义
* 通过在类型名标记`final`可以防止继承发生
* 派生类的构造函数应只初始化他的直接基类

> 在派生类对象中含有与基类对应的组成部分,这一个事实是继承的关键所在

##### 静态成员
* 如果基类定义了一个静态成员,则整个继承体系中只存在该成员的唯一定义
* 遵循通用的访问控制规则

##### 自动类型转换
* 从派生类向基类的类型转换只对指针或引用类型有效
* 基类向派生类不存在隐式类型转换
* 派生类向基类的转换可能会由于访问受限而不可行

>尽管自动类型转换只对指针或引用类型有效,但继承体系中的大多数类仍然(显示或隐式地)定义了拷贝控制成员,因此我们通常能将一个派生类对象拷贝,移动,赋值给一个基类对象,不过要注意的是,这种操作只处理派生类对象的基类部分

##### 访问控制
* 派生类访问说明符和基类的访问说明符共同决定了基类成员被派生类继承后的权限
    * `private`基类的访问说明符都为private
    * `protected`基类的public变成protected,其余不变
    * `public`访问权限不变
* 派生类访问说明符决定了派生类向基类转换的访问权限
    * 派生类的成员和友元始终可以使用转换
    * `public`用户可以使用转换
    * `protected`用户不可以使用转换,但是派生类的派生类内可以使用转换
    * `private`用户不可以使用转换


>可以使用using改变某个名字的访问级别

##### 构造函数的继承
* 不能继承默认,拷贝和移动构造函数(即使派生类没有),除此以外可以继承
* 无法使用`using`改变继承的构造函数访问级别
* 当基类构造函数含有默认实参,则派生类获得多个继承的构造函数(实参有无的所有情况)


##### 继承中的类作用域
* 派生类的作用域在基类作用域之类

## 虚函数
* `virtual`修饰的类函数称为**虚函数**
* 基类希望派生类进行覆盖的函数要声明为虚函数
* 如果派生类没有覆盖基类的虚函数,则虚函数的行为类似于普通成员
* 虚函数覆盖时,形参要完全一致,返回类型一致(为类本身的指针或引用时,符合自动类型转换也可)
* 虚函数随继承传递,,不需要用`virtual`再次修饰
* 函数声明末尾用`override`标记表示必须覆盖
* 虚函数可以拥有默认实参, 且实参值可不一样, 因为实参值由静态类型决定
    * 在基类上调用, 用的是基类的声明实参值
    * 在派生类上调用,用的是派生类的声明实参值
* 在虚函数声明语句末尾加上`=0`,则说明此虚函数为纯虚函数,`=0`只能出现在类内部的虚函数声明语句处

##### 抽象基类
* 含有或未经覆盖直接继承纯虚函数的类是**抽象基类**
* 不能创建抽象基类的对象
> 纯虚函数引入目的: 使派生类仅仅继承函数的接口, 而不提供缺省实现

##### 动态绑定
* 当使用基类的引用(或指针)调用一个虚函数时将发生**动态绑定**
* 由于是在运行时发生,所以又被称为**运行时绑定**

## 构造函数和拷贝控制
##### 虚析构函数
* 由于动态绑定的存在,需要将基类的析构函数定义为虚,否则delete一个指向派生类对象的基类指针将产生未定义的行为
* 派生类的析构函数会隐式的销毁直接基类(通过自动调用基类的析构)


##### 删除的拷贝控制和基类的关系
* 默认构造,拷贝构造,拷贝赋值构造,析构是删除的或不可访问->派生类对应对象是删除的
* 析构是删除的或不可访问的->派生类中合成的默认构造和拷贝构造函数是删除的,因为无法销毁派生类的基类部分
* 析构是删除的或不可访问的->派生类的移动构造函数是删除的

##### 合成的拷贝控制成员
* 合成的默认,拷贝,拷贝赋值,移动构造,移动赋值,析构函数会自动对基类进行相应操作
* 除析构函数外的所有自定义函数都需要自行控制基类

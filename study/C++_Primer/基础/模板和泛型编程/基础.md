# 基础

## 定义模板

```cpp
template <typename T, unsigned  M = 3>
inline int compare(const T &v1, const T &v2, char (&p)[M])
{
    if (v1 < v2)
        return -1;
    if (v2 < v1)
        return 1;
    return 0;
}
```

##### 概念
* `<typename T>`是**模板参数列表**, 模板参数列表不能为空
* `typename T`是**模板参数**, 用逗号分隔
* 当时用模板时, 我们隐式或显示的指定**模板实参**, 将其绑定到模板参数上
* 使用模板时, 会发生**实例化**, 生成的版本称为模板的**实例**
* 模板参数可以是**非类型参数**, 通过一个特定的类型名指定
* 可以声明为inline或constexpr, 放在模板参数列表之后, 返回类型之前
* 使用**显式模板实参列表**, 可以进行**显式实例化**

##### 类模板
 * 类模板必须显式实例化
 * 类模板不是类型名
 * 定义在类模板之外的成员函数必须写全template语句
 * 对于一个实例化了的类模板, 其成员只有在使用时才被实例化
 * 在类模板的作用域类, 可以直接使用模板名而不指定模板实参
 * 如果一个类包含友元说明，则类与友元各自是否是模板是相互无关的
 * 可以为类模板定义类型别名，并可固定一个或多个模板参数

    ```cpp
    template <typename T>
    using twin = Blob<T, T, T>; //类模板 类型别名

    twin<int> my_blob;
    ```
  * 类的static成员每种实例独有，且只有在使用时才会实例化

    ```cpp
    Blob<int, int, int> blob;             //Blob是类模板
    num = Blob<int, int, int>::g_num;     //通过作用域
    num = blob.g_num;                     //通过实例
    num = Blob<int, int, int>::get_num(); //通过作用域
    num = blob.get_num();                 //通过实例
    ```
* 成员模板不能是虚函数

##### 模板参数
* 模板参数遵循普通的作用域，名字查找优先
* 在模板内不用重用模板参数名
    ```cpp
    inline int compare(const T)
    {
        // int T; 错误，模板参数不能重用
        return 0;
    }
    ```
* 一个给定模板的每个声明和定义必须有相同数量和种类的参数
* 可以为函数和类模板提供默认实参
    ```cpp
    template <typename T, unsigned  M = 3， typename F = int>
    ```
    如果都有默认实参，<>也是不能能省略的
    ```cpp
    template <typename T = int>
    class Blob{}

    Blob<> blob;
    ```

#### 显式实例化
* 实例化定义
    ```cpp
    template class Blob<int>; //实例化该类所有成员
    ```
    实例化定义与普通实例化不同,会实例化该类所有成员

* 显式实声明

    ```cpp
    extern template class Blob<int>;//这个模板必须在其他位置进行显式实例化,需链接对应.o文件
    Blob<int> blob;
    ```


## 模板实参推断
从函数实参来确定模板实参的过程被称为**模板实参推断**

#### 自动转换
只有以下两种转换
* 非const对象的引用或指针传递给一个const形参
* 数组或函数到指针的转换

#### 标准类型转换模板
对于以下代码

```cpp
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
    return *beg; //此处返回的是引用
}
```
只能返回引用，要想返回拷贝值，需使用**标准类型转换模板**

```cpp
template <typename It>
auto fcn2(It beg, It end) -> typename std::remove_reference<decltype(*beg)>::type
{
    return *beg; //此处返回的是值或右值
}
```

函数一览
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202112271320829.png)

* 如果不可能或者不必要转换模板参数，则type成员就是模板参数类型本身，否则将进行对应转换

#### 函数指针和实参推断
* 当函数入参是一个函数模板实例的地址时，程序上下文必须满足，对每个模板参数，能唯一确定其类型或值

#### 引用折叠
详见引用概念部分
引用折叠的存在, 导致模板参数可以被推断为一个引用类型,如下
```cpp
template <typename T>
void f2(T &&val)
{
    T t = val; //拷贝还是绑定一个引用？
}
```
* 当val传入右值时,为拷贝
* 当val传入左值时,为绑定引用

## 重载与模板
函数模板匹配优先级
* 首先列出所有可用函数模板
* 精确匹配优先级（见函数重载部分）
* 非模板函数优先
* 特例优先

## 可变参数模板

```cpp
    void foo() {}
    //可变参数模板
    template <typename T, typename... Args>
    void foo(const T &t, const Args &...rest) //...拓展Args
    {
        sizeof...(Args);//类型参数的数目
        sizeof...(rest);//函数参数的数目
        
        return foo(rest...);//rest右边放置...表示拓展rest
    }
```

* 接受可变数目参数的模板函数或模板类
* 可变数目(>=0)的参数被称为`参数包`, 分为`模板参数包`和`函数参数包`
* `class...`或`typename...`指出接下来的参数表示>=0个的多个类型模板参数包
* 类型后面跟着`...`表示>=0个给定类型模板参数包

#### 参数包操作
* 获取大小
    *  `sizeof...`可以返回参数包的元素个数
* 包拓展
    * 将包分解为构成的元素, 对每个元素应用模式, 获得拓展后的列表
    * 在模式右边放`...`触发拓展

## 模板特例化
* 包括`函数模板特例化`和`类模板特例化`
* 本质是接管了编译器的工作, 提供了一个实例, 而非重载版本
* 遵循类模板和函数模板的匹配优先级
* `函数模板特例化`时必须为每个模板参数提供实参
* `类模板特例化`时可以提供部分实参, 称为`类模板部分特例化`
* `类模板部分特例化`本身就是一个模板, 使用时还必须为那些在特例化版本中未指定的模板提供实参

```cpp
//函数模板特例化
template <typename T>
int compare(const T &, const T &){}; //可比较任意两个类型

template <>                                                  //空<>说明我们将为原模版所有模板参数提供实参
int compare(const char *const &p1, const char *const &p2){}; //可以比较字符串字面常量

//原始的,最通用的版本
template <typename T, typename M>
struct remove_reference
{
    typedef T type;
};

//类模板部分特例化版本,将用于左值和右值引用
template <typename T>
struct remove_reference<T &, int>
{
    typedef T type; //左值引用
};
template <typename T>
struct remove_reference<T &&, int>
{
    typedef T type; //右值引用
};

//类模板全部特例化版本,也叫显式特例化
template <>
struct remove_reference<int, int>
{
};

```


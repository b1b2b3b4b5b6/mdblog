<!--
author: lumos
date: 2026-02-04
title:  
tags: 
category: 
status: draft
summary: 
-->


# 容器实现原理

本文档详细说明各种标准容器的底层实现、数据结构和迭代器机制。

## 概览对比

| 容器           | 底层实现        | 内存连续性  | 迭代器类型     | 迭代器实现 |
|:--------------|:---------------|:-----------|:--------------|:----------|
| array         | 静态数组        | ✅ 完全连续 | 随机访问       | 指针       |
| vector        | 动态数组        | ✅ 完全连续 | 随机访问       | 指针/轻量类 |
| string        | 动态字符数组    | ✅ 完全连续 | 随机访问       | 指针/轻量类 |
| deque         | 分段数组        | ⚠️ 块内连续 | 随机访问       | 类类型     |
| list          | 双向链表        | ❌ 分散     | 双向          | 类类型     |
| forward_list  | 单向链表        | ❌ 分散     | 前向          | 类类型     |
| map/set       | 红黑树          | ❌ 分散     | 双向          | 类类型     |
| unordered_map | 哈希表(拉链法)  | ❌ 分散     | 前向          | 类类型     |

## array

### 底层实现
```C++
template<class T, size_t N>
struct array {
    T elems[N];  // 直接内嵌静态数组
};
```

### 内存布局
```
连续内存：[elem0][elem1][elem2]...[elemN-1]
```

### 迭代器实现
```C++
using iterator = T*;
using const_iterator = const T*;

iterator begin() { return elems; }
iterator end() { return elems + N; }
```

**特点**：
- 迭代器就是裸指针
- 零开销抽象
- 栈上分配（作为成员时）

## vector

### 底层实现
```C++
template<class T>
class vector {
    T* data_;       // 指向动态分配的数组
    size_t size_;   // 当前元素个数
    size_t capacity_; // 容量
};
```

### 内存布局
```
堆上连续内存：
data_ → [elem0][elem1][elem2]...[未使用]...[capacity边界]
        ↑                       ↑             ↑
      begin()                 end()        预留空间
```

### 迭代器实现
**方式1：指针（常见优化实现）**
```C++
using iterator = T*;
```

**方式2：包装类（调试/检查版本）**
```C++
class iterator {
    T* ptr_;
    const vector* container_; // 调试用：检查迭代器失效
public:
    T& operator*() const { 
        check_valid(); // 边界检查
        return *ptr_; 
    }
    iterator& operator++() { ++ptr_; return *this; }
    // ...
};
```

### 扩容机制
- 容量不足时重新分配（通常增长1.5倍或2倍）
- 拷贝/移动所有元素到新内存
- 释放旧内存
- **导致所有迭代器、引用、指针失效**

### 插入/删除
```C++
// 中间插入：O(n)
insert(pos, val):
    if (size_ == capacity_) reallocate();
    move(pos, end(), pos+1);  // 后移元素
    *pos = val;
```

## string

### 底层实现
与 `vector<char>` 类似，但有优化：

**小字符串优化（SSO, Small String Optimization）**：
```C++
class string {
    union {
        char small_[16];  // 短字符串直接存储
        struct {
            char* ptr_;
            size_t size_;
            size_t capacity_;
        } large_;
    };
    // 根据长度选择使用 small_ 或 large_
};
```

**内存布局**：
- 短字符串（<16字符）：栈上存储，无堆分配
- 长字符串：堆上连续数组

### 迭代器实现
与 vector 类似（指针或轻量包装类）

## deque

### 底层实现
```C++
template<class T>
class deque {
    T** map_;           // 指针数组，每个元素指向一个块
    size_t map_size_;   // map数组大小
    // 记录首尾位置
};
```

### 内存布局
```
map_:  [ptr0][ptr1][ptr2][ptr3]...  (连续的指针数组)
         ↓     ↓     ↓     ↓
       块0   块1   块2   块3        (每个块是连续数组)
       [  ][  ][  ][  ]
       [  ][  ][  ][  ]
       [  ][  ][  ][  ]
```

### 迭代器实现
```C++
class iterator {
    T* cur_;         // 当前元素
    T* first_;       // 当前块起始
    T* last_;        // 当前块结束
    T** node_;       // 指向 map 中的块指针
    
    iterator& operator++() {
        ++cur_;
        if (cur_ == last_) {  // 跨块
            ++node_;
            cur_ = *node_;
            first_ = *node_;
            last_ = first_ + block_size;
        }
        return *this;
    }
};
```

### 随机访问实现
```C++
T& operator[](size_t n) {
    size_t block = n / block_size;
    size_t offset = n % block_size;
    return map_[block][offset];
}
```

**特点**：
- 两端插入 O(1)
- 随机访问 O(1)，但比 vector 慢（多一次间接寻址）
- 块内连续，块间不连续

## list

### 底层实现
```C++
template<class T>
class list {
    struct Node {
        T data;
        Node* prev;
        Node* next;
    };
    Node* head_;  // 哨兵节点
    size_t size_;
};
```

### 内存布局
```
哨兵节点 ⇄ node1 ⇄ node2 ⇄ node3 ⇄ 哨兵节点
  ↑                                    ↑
head_                              (形成环)

堆上各处：
  node1 → 0x1000
  node2 → 0x3500
  node3 → 0x2100
```

### 迭代器实现
```C++
class iterator {
    Node* ptr_;
public:
    T& operator*() const { return ptr_->data; }
    iterator& operator++() { 
        ptr_ = ptr_->next; 
        return *this; 
    }
    iterator& operator--() { 
        ptr_ = ptr_->prev; 
        return *this; 
    }
};
```

**特点**：
- 迭代器是类类型（封装 Node*）
- 双向迭代器（支持 `++` 和 `--`）
- 不支持随机访问（无 `+n` 操作）
- 插入/删除不使其他迭代器失效

## map / set

### 底层实现
```C++
template<class Key, class T>
class map {
    struct Node {
        pair<const Key, T> value;
        Node* left;
        Node* right;
        Node* parent;
        Color color;  // 红黑树颜色
    };
    Node* root_;
    Node* header_;  // 哨兵，header->left 指向最小，header->right 指向最大
    size_t size_;
};
```

### 红黑树性质
- 节点非红即黑
- 根节点是黑色
- 红节点的子节点必为黑
- 任一节点到叶子的路径包含相同数量黑节点
- 保证高度 O(log n)

### 内存布局
```
树形结构（逻辑）：
        node(k:5)
       /         \
   node(k:3)   node(k:7)
   /      \       /    \
 n(1)   n(4)   n(6)  n(9)

物理内存（分散）：
  node1 → 0x1200
  node2 → 0x3800
  node3 → 0x1500
  ...
```

### 迭代器实现
```C++
class iterator {
    Node* ptr_;
    
    iterator& operator++() {
        // 中序遍历的下一个节点（后继）
        if (ptr_->right) {
            // 有右子树：后继是右子树的最小节点
            ptr_ = min_node(ptr_->right);
        } else {
            // 无右子树：向上找第一个"当前节点在其左子树"的祖先
            Node* p = ptr_->parent;
            while (p && ptr_ == p->right) {
                ptr_ = p;
                p = p->parent;
            }
            ptr_ = p;
        }
        return *this;
    }
    
    iterator& operator--() {
        // 中序遍历的前一个节点（前驱）
        if (ptr_->left) {
            // 有左子树：前驱是左子树的最大节点
            ptr_ = max_node(ptr_->left);
        } else {
            // 无左子树：向上找第一个"当前节点在其右子树"的祖先
            Node* p = ptr_->parent;
            while (p && ptr_ == p->left) {
                ptr_ = p;
                p = p->parent;
            }
            ptr_ = p;
        }
        return *this;
    }
};
```

**为什么是双向迭代器**：
- **存储 parent 指针**：可以向上回溯
- **中序遍历特性**：前驱/后继关系明确
- **O(log n) 平均复杂度**：找前驱/后继高效

**为什么不是随机访问迭代器**：
- 树结构无法通过索引直接定位第 n 个元素
- 没有连续内存，无法指针算术 `iter + n`
- 要访问第 n 个元素，必须从某处遍历 n 次

**特点**：
- 迭代器遍历顺序是有序的（中序遍历）
- 双向迭代器（支持 `++` 和 `--`）
- 插入/删除只使被删除节点迭代器失效
- 自平衡，查找 O(log n)

## unordered_map / unordered_set

### 底层实现
```C++
template<class Key, class T>
class unordered_map {
    struct Node {
        pair<const Key, T> value;
        Node* next;  // 链表下一个
    };
    
    Node** buckets_;      // 桶数组
    size_t bucket_count_; // 桶数量
    size_t size_;         // 元素数量
    float max_load_factor_; // 最大负载因子
};
```

### 内存布局
```
buckets_: [ptr0][ptr1][ptr2][ptr3]...  (连续的指针数组)
            ↓     ↓     ↓     ↓
          链表  nullptr 链表   链表
           ↓             ↓     ↓
         node1         node4  node5
           ↓                    ↓
         node2                node6
           ↓
         node3

堆上各处（节点分散）：
  node1 → 0x2000
  node2 → 0x4500
  ...
```

### 查找过程
```C++
T& operator[](const Key& k) {
    size_t idx = hash(k) % bucket_count_;
    Node* p = buckets_[idx];
    while (p) {
        if (p->value.first == k) return p->value.second;
        p = p->next;
    }
    // 未找到，插入新节点
}
```

### 迭代器实现
```C++
class iterator {
    Node* node_;         // 当前节点
    Node** bucket_;      // 当前桶
    Node** buckets_end_; // 桶数组末尾
    
    iterator& operator++() {
        node_ = node_->next;
        if (!node_) {  // 链表结束，跳到下一个非空桶
            ++bucket_;
            while (bucket_ != buckets_end_ && !*bucket_)
                ++bucket_;
            node_ = (bucket_ != buckets_end_) ? *bucket_ : nullptr;
        }
        return *this;
    }
    
    // 注意：不支持 operator--（前向迭代器）
};
```

**为什么只是前向迭代器**：
- **链表是单向的**：节点只有 `next` 指针，没有 `prev`
- **无需双向遍历**：哈希表本身无序，回退没有意义
- **节省内存**：每节点省 8 字节（一个指针）

**限制**：
```C++
unordered_map<int, int> m;
auto it = m.begin();

++it;   // ✅ 可以：前向遍历
--it;   // ❌ 编译错误：不支持后退
it + 5; // ❌ 编译错误：不支持随机访问
```

### 扩容（rehash）
```C++
void rehash(size_t new_count) {
    // 分配新桶数组
    Node** new_buckets = new Node*[new_count];
    // 重新插入所有元素
    for (size_t i = 0; i < bucket_count_; ++i) {
        Node* p = buckets_[i];
        while (p) {
            Node* next = p->next;
            size_t new_idx = hash(p->value.first) % new_count;
            // 头插法插入新桶
            p->next = new_buckets[new_idx];
            new_buckets[new_idx] = p;
            p = next;
        }
    }
    delete[] buckets_;
    buckets_ = new_buckets;
    bucket_count_ = new_count;
}
```

**特点**：
- 平均 O(1) 查找，最坏 O(n)
- 迭代顺序不确定
- 插入可能触发 rehash（所有迭代器失效）
- 负载因子 = size / bucket_count

## 性能对比

### 插入性能
| 容器          | 尾部插入 | 头部插入 | 中间插入 |
|:-------------|:--------|:--------|:---------|
| vector       | O(1)摊销 | O(n)    | O(n)     |
| deque        | O(1)    | O(1)    | O(n)     |
| list         | O(1)    | O(1)    | O(1)已知位置 |
| map          | O(log n)| O(log n)| O(log n) |
| unordered_map| O(1)平均| O(1)平均| O(1)平均 |

### 查找性能
| 容器          | 随机访问 | 查找    | 排序   |
|:-------------|:--------|:--------|:-------|
| vector/array | O(1)    | O(n)    | 否     |
| deque        | O(1)    | O(n)    | 否     |
| list         | O(n)    | O(n)    | 否     |
| map          | O(log n)| O(log n)| 有序   |
| unordered_map| -       | O(1)平均| 无序   |

### 内存开销
| 容器          | 每元素额外开销      |
|:-------------|:-------------------|
| vector/array | 无（紧凑）          |
| deque        | 小（块指针开销）     |
| list         | 16字节（2指针）     |
| map          | 32字节（3指针+颜色） |
| unordered_map| 8字节（1指针）      |

## 迭代器失效规则

### vector/string
- 插入：插入点及之后失效
- 删除：删除点及之后失效
- 扩容：全部失效

### deque
- 中间插入/删除：全部失效
- 首尾插入：迭代器失效，引用/指针有效

### list
- 插入：不失效
- 删除：仅被删除元素失效

### map/set
- 插入：不失效
- 删除：仅被删除元素失效

### unordered_map
- 插入：rehash 时全部失效
- 删除：仅被删除元素失效

## 选择建议

**需要随机访问**：
- 固定大小 → `array`
- 动态大小 → `vector`

**需要两端操作**：
- `deque`（滑动窗口、队列）

**频繁中间插入删除**：
- `list`

**需要排序查找**：
- `map/set`

**需要快速查找**：
- `unordered_map/unordered_set`

**内存紧张**：
- `vector/array`（最紧凑）

**迭代器稳定性要求高**：
- `list/map`

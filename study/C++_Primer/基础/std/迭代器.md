<!--
author: lumos
date: 2020-12-11
title:  
tags: 
category: 
status: draft
summary: 
-->


# 迭代器
有三个含义：
- 迭代器概念本身
- 容器定义的迭代器类型
- 指某个迭代器对象
下面讨论的都指**容器定义的迭代器类型**

##### 本质
指针或类类型（具体由容器实现决定）
- `array` 迭代器本质为指针
- `vector/string` 通常是指针或轻量包装类（标准仅要求连续迭代器）
    - 由编译器/标准库实现与编译选项决定，用户不应依赖其具体类型。
        - 发布版：通常直接用指针以获得最小开销。
        - 调试/安全检查开启时：可能用轻量包装类，记录容器信息、边界检查、迭代器失效检测等。
        - 库实现策略：为了ABI稳定或与连续迭代器概念对齐，也可能始终用包装类。
    
- `deque/list/map/set` 迭代器为类类型（非指针）

##### 性质
- 访问容器对象的元素
- 所有标准容器都可以使用迭代器，其中string（非容器），vector支持下标操作
- 迭代器分为有效和无效
	- 有效：指向某个元素，或者指向容器尾元素的下一个位置（尾后迭代器）
	- 无效：上述其他所有情况

##### 使用迭代器
容器迭代器类型
- const_iterator：对指示元素只能读取，不能写
- iterator：能对指示元素读写
```C++
vector<int>::interator it1;		//可读写所指vector<int>的元素
vector<int>::const_iterator itr	//只可读所指vector<int>的元素
```
使用容器的返回迭代器类型成员
- begin成员：返回一个指向第一个元素（字符）的迭代器
- end成员：返回尾后迭代器，目的方便代码编写
![](http://lumosblog.cn:8081/images/2020/04/21/1.png)
```C++
const vector<int> it;
auto it = v.begin();		//it的类型是vector<int>::inerator
auto it = v.end();			//it的类型是vector<int>::inerator
```
>注：begin和end成员返回的具体类型由对象是否为const决定
>C++11新特性：cbegin和cend类似于begin和end，但是返回const_iterator类型


##### 标准迭代器操作
| 操作                         | 说明                                                                        |
| :--------------------------- | :-------------------------------------------------------------------------- |
| iter->mem                    | 等价于(*iter).mem                                                           |
| ++iter                       | 令iter指示下一个元素                                                         |
| --iter                       | 令iter指示上一个元素                                                         |
| iter1==iter2<br>iter1!=iter2 | 如果俩个迭代器指示同一个元素，或者他们是同一个容器的尾后迭代器，则相等，反之，不相等 |
##### vector和string迭代器支持的运算
| 操作           | 说明                                                                     |
| :------------ | :---------------------------------------------------------------------- |
| iter + n      | 返回迭代器，指示的位置向后移动了n                                           |
| iter - n      | 返回迭代器，指示的位置向前移动了n                                           |
| iter1 - iter2 | 迭代器指示元素位置差（两者必须有效），为带符号difference_type类型（+操作非法） |
| >, >=, <, <=  | 比较位置（两者必须有效）                                                   |

##### 迭代器失效情况
- 在范围for循环中向vector对象添加元素
- 改变vector容量的操作，比如push_back
>但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。

##### 迭代器实现
常见迭代器类别：
- 输入迭代器（Input）
- 输出迭代器（Output）
- 前向迭代器（Forward）
- 双向迭代器（Bidirectional）
- 随机访问迭代器（Random Access）
- 连续迭代器（Contiguous，C++20）

自定义迭代器需要满足对应类别的操作约束，并提供以下类型别名：
- value_type
- difference_type
- reference
- pointer
- iterator_category（C++20可用iterator_concept）

标准库通过std::iterator_traits萃取这些信息：
```C++
using value_type = typename std::iterator_traits<Iter>::value_type;
using difference_type = typename std::iterator_traits<Iter>::difference_type;
```

最小前向迭代器示例（包装裸指针）：
```C++
template <class T>
class SimpleIter {
public:
	using value_type = T;
	using difference_type = std::ptrdiff_t;
	using pointer = T*;
	using reference = T&;
	using iterator_category = std::forward_iterator_tag;

	SimpleIter() : p_(nullptr) {}
	explicit SimpleIter(T* p) : p_(p) {}

	reference operator*() const { return *p_; }
	pointer operator->() const { return p_; }

	SimpleIter& operator++() { ++p_; return *this; }
	SimpleIter operator++(int) { SimpleIter tmp(*this); ++(*this); return tmp; }

	friend bool operator==(const SimpleIter& a, const SimpleIter& b) { return a.p_ == b.p_; }
	friend bool operator!=(const SimpleIter& a, const SimpleIter& b) { return a.p_ != b.p_; }

private:
	T* p_;
};
```

实现要点：
- **解引用与箭头**：提供`operator*`与`operator->`
- **自增/自减**：前置与后置运算满足语义
- **比较**：同容器迭代器可比较相等
- **稳定性**：迭代器应避免悬空引用（与容器生命周期一致）
- **const版本**：可通过模板或转换构造实现`iterator`到`const_iterator`

#### std::iterator_traits的必要
我们先回忆一下，标准库提供的算法的一些特征：
- 参数一般包括iterator。
- 要根据iterator的种类，和iterator包装的元素的类型等信息，来决定使用最优化的算法。
    - 比如如果是vector的iterator，那么就可以使用+，-操作；
    - 如果是list的iterator，那么就不可以使用+，-操作。
所以，算法必须知道一些关于iterator的信息。

有一些容器对应的iterator是个类，所以在这个类里，定义了如下的信息：
```c++
template<typename T>
struct __list_iterator { 
  typedef bidirectional_iterator_tag     iterator_category;
  typedef T                              value_type;
  typedef T*                             pointer;
  typedef T&                             reference;
  typedef ptrdiff_t                      difference_type;
```
然而vector，array的iterator并不是类，而是c++里内置的指针, 无法通过上述方式获取信息
所以需要创建一个`iterator_traits`类，它包装了`iterator`，并使用模板局部特化技术，萃取需要的类型
- 对于`iterator`类, 用类里的类型
- 对于指针, 特化返回类型
```c++
//使用iterator提供的信息
template<typename Iterator>
struct iterator_traits
{
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type        value_typep;
  typedef typename Iterator::difference_type   difference_type;
  typedef typename Iterator::pointer           pointer;
  typedef typename Iterator::reference         reference;
};


//由于无法使用iterator的信息，所以traits自己提供了。
//局部特化，c++内置指针。
template<typename T>
struct iterator_traits<const T *>
{
  typedef random_access_iterator_tag iterator_category;
  typedef T                          value_type;//注意这里不是const T;如果是const T，算法拿到这个类型，用这个类型定义变量后，却无法改变其值，那就没有作用了，所以是T。
  typedef ptrdiff_t                  difference_type;
  typedef const T*                   pointer;
  typedef const T&                   reference;
};

```
这样算法向iterator_traits类要它需要的信息, 并在编译阶段就确定使用方式








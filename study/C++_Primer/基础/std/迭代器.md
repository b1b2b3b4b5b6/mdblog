<!--
author: lumos
date: 2020-12-11
title:  
tags: 
category: 
status: draft
summary: 
-->


# 迭代器
有三个含义：
- 迭代器概念本身
- 容器定义的迭代器类型
- 指某个迭代器对象
下面讨论的都指**容器定义的迭代器类型**
##### 本质
指针

##### 性质
- 访问容器对象的元素
- 所有标准容器都可以使用迭代器，其中string（非容器），vector支持下标操作
- 迭代器分为有效和无效
	- 有效：指向某个元素，或者指向容器尾元素的下一个位置（尾后迭代器）
	- 无效：上述其他所有情况
##### 使用迭代器
容器迭代器类型
- const_iterator：对指示元素只能读取，不能写
- iterator：能对指示元素读写
```C++
vector<int>::interator it1;		//可读写所指vector<int>的元素
vector<int>::const_iterator itr	//只可读所指vector<int>的元素
```
使用容器的返回迭代器类型成员
- begin成员：返回一个指向第一个元素（字符）的迭代器
- end成员：返回尾后迭代器，目的方便代码编写
![](http://lumosblog.cn:8081/images/2020/04/21/1.png)
```C++
const vector<int> it;
auto it = v.begin();		//it的类型是vector<int>::inerator
auto it = v.end();			//it的类型是vector<int>::inerator
```
>注：begin和end成员返回的具体类型由对象是否为const决定
>C++11新特性：cbegin和cend类似于begin和end，但是返回const_iterator类型


##### 标准迭代器操作
| 操作                         | 说明                                                                        |
| :--------------------------- | :-------------------------------------------------------------------------- |
| iter->mem                    | 等价于(*iter).mem                                                           |
| ++iter                       | 令iter指示下一个元素                                                         |
| --iter                       | 令iter指示上一个元素                                                         |
| iter1==iter2<br>iter1!=iter2 | 如果俩个迭代器指示同一个元素，或者他们是同一个容器的尾后迭代器，则相等，反之，不相等 |
##### vector和string迭代器支持的运算
| 操作           | 说明                                                                     |
| :------------ | :---------------------------------------------------------------------- |
| iter + n      | 返回迭代器，指示的位置向后移动了n                                           |
| iter - n      | 返回迭代器，指示的位置向前移动了n                                           |
| iter1 - iter2 | 迭代器指示元素位置差（两者必须有效），为带符号difference_type类型（+操作非法） |
| >, >=, <, <=  | 比较位置（两者必须有效）                                                   |

##### 迭代器实现
常见迭代器类别：
- 输入迭代器（Input）
- 输出迭代器（Output）
- 前向迭代器（Forward）
- 双向迭代器（Bidirectional）
- 随机访问迭代器（Random Access）
- 连续迭代器（Contiguous，C++20）

自定义迭代器需要满足对应类别的操作约束，并提供以下类型别名：
- value_type
- difference_type
- reference
- pointer
- iterator_category（C++20可用iterator_concept）

标准库通过std::iterator_traits萃取这些信息：
```C++
using value_type = typename std::iterator_traits<Iter>::value_type;
using difference_type = typename std::iterator_traits<Iter>::difference_type;
```

最小前向迭代器示例（包装裸指针）：
```C++
template <class T>
class SimpleIter {
public:
	using value_type = T;
	using difference_type = std::ptrdiff_t;
	using pointer = T*;
	using reference = T&;
	using iterator_category = std::forward_iterator_tag;

	SimpleIter() : p_(nullptr) {}
	explicit SimpleIter(T* p) : p_(p) {}

	reference operator*() const { return *p_; }
	pointer operator->() const { return p_; }

	SimpleIter& operator++() { ++p_; return *this; }
	SimpleIter operator++(int) { SimpleIter tmp(*this); ++(*this); return tmp; }

	friend bool operator==(const SimpleIter& a, const SimpleIter& b) { return a.p_ == b.p_; }
	friend bool operator!=(const SimpleIter& a, const SimpleIter& b) { return a.p_ != b.p_; }

private:
	T* p_;
};
```

实现要点：
- **解引用与箭头**：提供`operator*`与`operator->`
- **自增/自减**：前置与后置运算满足语义
- **比较**：同容器迭代器可比较相等
- **稳定性**：迭代器应避免悬空引用（与容器生命周期一致）
- **const版本**：可通过模板或转换构造实现`iterator`到`const_iterator`
##### 迭代器失效情况
- 在范围for循环中向vector对象添加元素
- 改变vector容量的操作，比如push_back
>但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。
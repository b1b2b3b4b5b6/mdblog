# const
## 修饰变量
* 被const修饰的变量，一但创建（编译后运行时）后无法改变
* const修饰的变量默认符号类型为`local`,不参与链接决议
* 定义const变量必须初始化
    * 定义类时不用赋值, 因为类本身就会初始化
    * 类内成员变量不用，因为类内成员属于声明
* 除了引用和指针外, const修饰的位置无影响


### 变量位置
#### 类外
* 修饰的是class, 总是放在`.bss`
* 修饰的是基本类型
    * 初始化值编译时确定, 且后续无取地址操作(被引用也算), 不分配内存, 当作`立即数`编译
    * 在上面基础上, 有后续取地址操作(被引用也算), 放在`.rodata`
    * 初始化值不确定, 放在`.bss`
>修饰static局部变量时, 不会当作立即数编译, 其余符合上述规则

#### 类内
* 修饰的成员变量(除了static)总是被分配内存, 具体位置视类实例内存位置
* 若修饰的成员变量被static修饰
    * 若未定义, 且初始值确定, 则当作`立即数`编译
    * 若自己定义, 且初始值确定, 则放在`.rodata`
    * 若自己定义, 且初始值不确定, 则放在`.bss`
> 有趣的是, 当`static const 成员变量`在声明时指定初始值时, 对读操作, 会直接使用初始值; 
> 对`取地址`的相关操作时, 仍会使用符号(自己或其他文件导出的)
```C++
class OBJ {
public:
  static const int k = 2;

public:
  OBJ() {}
};
const int OBJ::k;
int main() {
  cout << OBJ::k << std::endl;
  cout << *(&OBJ::k) << std::endl;
  return 0;
}
//输出
//2
//5(链接决议得到的符号所代表的值)
```
## 修饰成员函数
```C++
class OBJ{
    void ConstFoo() const
    {
       ...;
    }
}
```
* const修饰的成员函数可以接受指向`const OBJ`的指针（一般成员函数不能）
* const修改的成员函数只可修改mutable和static成员变量
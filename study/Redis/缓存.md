# 缓存
## 问题
### 缓存和数据库一致性问题
* 如果项目对缓存的要求是强一致性的，那就不能用缓存
* 采取合适的策略来减低缓存和数据库间数据不一致的概率
    * 合适的缓存更行策略
    * 更新数据库后及时更新缓存
    * 缓存失败增加重试机制
 
### 缓存穿透
用户不断请求缓存和数据库中不存在的数据
* 接口层增加校验，比如用户鉴权，参数校验
* 布隆过滤器（key不存在直接拒绝）

### 缓存击穿
热点数据失效瞬间，大量数据请求打到数据库
* 热点数据永不失效

### 缓存雪崩
大量数据同一时间失效，打到数据库
* 避免设置相同过期时间

## 淘汰策略
|       策略       |                  描述                  |
| --------------- | -------------------------------------- |
| volatile-lru    | 从已设置过期时间的KV中优先淘汰最近最少使用 |
| volatile-ttl    | 从已设置过期时间的KV中优先淘汰剩余时间短的 |
| volatile-random | 从已设置过期时间的KV中随机淘汰            |
| allkeys-lru     | 从所有KV中优先淘汰最近最少使用            |
| allkeys-random  | 从所有KV中优先随机淘汰                   |
| noeviction      | 不淘汰，若超过最大内存，返回错误信息       |

### 过期建删除策略
* `定时删除`:在设置键的过期时间的同时，创建一个定时器(timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。
* `惰性删除`:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
* `定期删除`:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。
# 主从复制
## 大致流程
* 从节点执行slaveof[masterIP][masterPort]，保存主节点信息
* 从节点中的定时任务发现主节点信息，建立和主节点的socket连接
* 从节点发送Ping信号，主节点返回Pong，两边能互相通信
* 连接建立后，主节点将所有数据发送给从节点（数据同步）
* 主节点就会持续的把写命令发送给从节点，保证主从数据一致性

## psync
![](https://raw.githubusercontent.com/b1b2b3b4b5b6/pic/main/PicGo/202210241046848.png)

> `rundId`redis重启后生成的为唯一uuid

### 全量复制
 * 在slave第一次连接psync时，runId填的?，offset填的-1，因为slave此时还不知道master的uuid
 * master发现 slave是第一次复制时，返回FULLRESYNC {runId} {offset}
 * 从节点接收主节点信息后，保存到info中
 * 主节点在发送FULLRESYNC后，启动bgsave命令，生成RDB文件（数据持久化）
 * 主节点发送RDB文件给从节点。到从节点加载数据完成这段期间主节点的写命令放入缓冲区
 * 从节点清理自己的数据库数据
 * 从节点加载RDB文件，将数据保存到自己的数据库中
 * 如果从节点开启了AOF，从节点会异步重写AOF文件

### 部分复制
* 主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区依然可以保存最近一段时间的写命令数据
* 当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当做psync参数发送给主节点，要求进行部分复制
* 主节点接收到psync命令后首先核对参数runId是否与自身一致，之后根据参数offset在复制积压缓冲区中查找，如果offset之后的数据存在，则对从节点发送+COUTINUE命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制
* 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态

## 问题
* master宕机后，需要人工干预（修改应用方的地址）
* master的写能力收到单机的限制
* master的存储能力收到单机的限制

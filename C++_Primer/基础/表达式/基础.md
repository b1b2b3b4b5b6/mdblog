# 基础
- 一个符号到底是一元运算符还是二元运算符由它的上下文决定
- 优先级规定了对象的组合方式，但是没有说明对象按照什么顺序求值

## 左右值
- 左值：用的是对象的身份（内存中的位置）
- 右值：用的是对象的值（内容,一般为临时值）

## 赋值运算符
- 赋值运算的结果是他的左侧运算对象，并且是一个左值，结果的类型是左侧对象的类型
- 如果左右两个运算对象类型不同，则右侧转换成左侧的类型
- 如果左侧对象是内置类型，则初始值列表最多只能包含一个值
- 对于类类型来说，运算的细节由类本身决定
- 初始值列表可以为空

## ++和--操作符
- 前置版本得到递增之后的值
- 后置版本得到递增之前的值

## sizeof
- 对解引用指针执行sizeof得到指针所指向的对象所占空间的大小，指针不需有效
- sizeof运算不会吧数组转换成指针来处理
- 对string或vector执行sizeof只返回该类型固定部分的大小

## 逗号运算符
- 首先对左侧求值，然后丢弃
- 结果为右侧表达式的值

## 求值顺序
- 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求求值
- 只有`&& || ?: ,`按规定先求左侧值

## 隐式转换
* 数组转换成指针
* 指针的转换
    * 整数值0或字面值nullptr转换成任意指针类型
    * 任意指向非常量的指针转换成void*
    * 任意指针转换成const void*
    * ...
* 从算数类型或指针类型到布尔类型的转换
* 转换成常量,如`int i; const int &j = i`
* 类类型定义的转换
    * 类类型能定义由编译器自动执行的转换, 但是**每次只能执行一种类类型的转换**,如下
    ```c++
    string s = "asldjfl";
    ```

## 强制转换

```C++
cast-name<type>(expression)
```
>`type` 转换的目标类型
>`expression` 转换的值
>`cast-name` 知道了执行的是那种转换

### static_cast
只要不包含底层const, 都可以使用

### const_cast
只能改变运算对象的底层const
```C++
const char *pc;
char *p = const_cast<char*>(pc);//正确,但是未定义行为
```
对于将常量对象转换为非常量对象的行为, 称其为`去掉const性质`

### dynamic_cast
支持运行时类型识别

### reinterpret_cast
为运算对象的位模式提供较低层次上的重新解释, 其本质上依赖于机器
```C++
int *ip;
char *pc = reinterpret_cast<char *>(ip);
```

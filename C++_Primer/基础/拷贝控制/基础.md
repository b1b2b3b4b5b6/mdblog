# 基础
格式一览

```c++
class Foo {
    Foo();                              //默认构造函数
    Foo(const Foo &);                   //拷贝构造函数
    Foo& operator=(const Foo&);         //拷贝赋值运算符
    Foo(Foo&&) noexcept;                //移动构造函数
    Foo& operator=(Foo &&) noexcept;    //移动赋值运算符
    ~Foo();                             //析构函数
}
```

## 拷贝构造函数和拷贝赋值运算符
第一个参数是自身类类型的引用,且额外参数都有默认值,形如

```C++
class Foo {
    Foo(const Foo &);                   //拷贝构造函数
    Foo& operator=(const Foo&);         //拷贝赋值运算符
}
```

>形参不加const也行, 但是加上const可以接受右值实参

### 合成拷贝构造函数和合成拷贝赋值运算符
* 如果没有定义拷贝构造函数和拷贝赋值运算符,编译器就会自动生成(与合成默认构造函数略有不同)
* 如果定义了移动构造或移动赋值运算符,则合成拷贝构造函数和合成拷贝赋值运算符会被定义成**删除**的
* 成员的类型决定了如何拷贝
    * 类类型:调用其拷贝构造函数
    * 数组:逐元素拷贝


### 拷贝初始化发生时机
* 使用`=`定义变量时
* 将对象传递给非引用形参
* 函数返回飞引用对象
* 列表初始化


## 移动构造函数和移动赋值运算符
* 第一个形参为右值引用,其余必须有默认实参
* 一般需要 `noexcept`
* 当没有定义任何拷贝控制成员,且所有成员都能移动构造或移动赋值时,编译器才会为它合成移动构造或移动赋值函数

### 定义为删除的函数
* 移动操作永远不会被隐式定义成删除的函数
* 若编译器不能移动所有成员,且显示的`=default`,则会被定义成删除的函数
    * 未定义移动构造或无法合成移动构造
    * 移动构造或移动赋值运算符时删除的或不可访问
    * 析构函数被定义为删除的或不可访问
    * 本身无法移动(比如const)

```c++
class Foo {
    Foo(Foo&&) noexcept;                //移动构造函数
    Foo& operator=(Foo &&) noexcept;    //移动赋值运算符
}
```


## 析构函数
* 析构部分是隐式的(成员实在析构函数体之后隐含的析构阶段中被销毁的)
* 成员析构发生什么依赖于成员的类型(内置类型没有析构函数)

### 析构函数调用时机
* 变量离开其作用域
* 当对象被析构时,其成员被析构
* 对于动态分配的对象,当指向他的指针用delete运算符时
* 对于临时对象,当创建他的完整表达式结束时

## 定义删除的函数
如下

```c++
class Foo {
    Foo(const Foo &) = delete;                   //阻止拷贝
    Foo& operator=(const Foo&) = delete;         //阻止赋值
    Foo(Foo&&) noexcept;                //移动构造函数
    Foo& operator=(Foo &&) noexcept;    //移动赋值运算符
    ~Foo();                             //阻止析构
}
```

* delete必须出现在第一次声明的时候
* 对于删除了析构函数的类型
    * 不能定义这种类型的变量或成员
    * 可以动态分配这种类型的对象,但是不能释放
* 如果一个类有数据成员不能默认构造,拷贝,复制或销毁,则对应的成员函数将被定义为删除的(移动类似,但是只有`=default`时,才会定义成删除,否则不生成)

## 三/五法则
自定义析构函数时,自定义拷贝构造函数,自定义拷贝赋值运算符同时出现或没有

## 引用限定符
问题如下

```c++
class Foo {
    Foo& operator=(const Foo&);         //拷贝赋值运算符                       
}
```
由于形参有`const`(const &可以绑定右值),故类似`s1+s2="123"`是可以的,但是哦我们不希望发生
故引入**引用限定符**

```C++
class Foo {
    Foo& operator=(const Foo&) &;         //只能用于左值
    Foo& operator=(const Foo&) &&;        //只能用于右值                       
}
```
* 需要同时出现在函数的声明和定义中
* 如果同时使用`const`和引用限定,则引用限定必须在`const`之后

```c++
    class Foo {
    Foo& operator=(const Foo&) const &;         //只能用于左值
    }
```
* 如果一个成员函数有引用限定符,则相同参数列表的所有版本都必须有引用限定符
